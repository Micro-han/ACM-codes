# 动态规划
## 区间dp

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e5+10;
const int mod=1e9+7;
const int INF=0x3f3f3f3f;
ll read(){
    ll f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
int n,a[510],dp[510][510],f[510][510];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
		dp[i][i]=1,f[i][i]=a[i];
	for(int len=2;len<=n;len++){
		for(int i=1;i<=n-len+1;i++){
			int j=i+len-1;
			dp[i][j]=INF;
			for(int k=i;k<=j-1;k++){
				if(dp[i][j]>=dp[i][k]+dp[k+1][j]){
					dp[i][j]=dp[i][k]+dp[k+1][j];
					if(dp[i][k]==1 && dp[k+1][j]==1 && f[i][k]==f[k+1][j]){
						dp[i][j]=1;
						f[i][j]=f[i][k]+1;
					} 
				}
			} 
		}
	} 
	printf("%d\n",dp[1][n]);
	return 0;
}
/*

 for(int i=1;i<=n;i++) dp[i][i]=0,s[i][i]=i;
     for(int r=1;r<n;r++){
         for(int i=1;i<n;i++){
             int j=i+r;
             if(j>n) break;
             dp[i][j]=INF;
             for(int k=s[i][j-1];k<=s[i+1][j];k++){
                 if(dp[i][j]>dp[i][k]+dp[k+1][j]){
                     dp[i][j]=dp[i][k]+dp[k+1][j];
                     s[i][j]=k;
                 }
             }
             dp[i][j]+=sum[j]-sum[i-1];
         }
     }
区间dp四边形优化 
*/
```

## 数位dp

```cpp
//数位dp
#include "stdio.h"
#include "string.h"
#include "iostream"
#include "algorithm"
#include "math.h"
using namespace std;
typedef long long LL;
const int maxn=1e5+10;
int a[20];
LL dp[20][state],le,ri;//state表示状态数量
LL dfs(int pos,bool lead,bool limit,int pre){//pos是state变量 lead前导零 limit数位上界
    if(pos==-1)return 1;
    if(!limit && !lead && dp[pos][state]!=-1)return dp[pos][state];
    int up=limit?a[pos]:9;
    LL ans=-;
    for(int i=0;i<=up;i++){
        if()
            else if()
                ans+=dfs(pos-1,lead && i==0 ,limit && i==a[pos]);
    }
    if(!limit && !lead)dp[pos][state]=ans;
    return ans;
}
LL solve(LL x){
    int pos=0;
    while(x){
        a[pos++]=x/10;
        x%=10;
    }
    return dfs(pos-1,true,true);
}
int main(){
    while(~scanf("%lld%lld",&le,&ri)){
        printf("%lld\n",solve(ri)-solve(le-1));
    }
    return 0;
}
```

## 超大背包

```cpp
#include <bits/stdc++.h>
using namespace std;
 
typedef long long ll;
const int MAXN = (int) 42;
const ll INF = (ll)0x3f3f3f3f3f3f3f3f;
 
//输入
int n;
ll w[MAXN],v[MAXN];
ll W;
 
pair<ll,ll> ps[1 << (MAXN/2)]; // 重量，价值
 
void solve(){
    // 枚举前半部分
    int n2 = n / 2;
    for (int i = 0;i < 1 << n2;i ++){
        ll sw = 0,sv = 0;
        for (int j = 0;j < n2;j ++){
            if (i >> j & 1){
                sw += w[j];
                sv += v[j];
            }
        }
        ps[i] = make_pair(sw,sv);
    }
 
    // 去除多余的元素
    sort(ps,ps + (1<<n2));
    int m = 1;
    for (int i = 1;i < 1 << n2;i ++){
        if (ps[m-1].second < ps[i].second) {
            ps[m++] = ps[i];
        }
    }
 
 
    // 枚举后半段部分并求解
    ll res = 0;
    for (int i = 0;i < 1 << (n-n2);i ++){
        ll sw = 0,sv = 0;
        for (int j = 0;j < n-n2;j ++){
            if (i >> j & 1 ){
                sw += w[n2+j];
                sv += v[n2+j];
            }
        }
        if (sw <= W){
            ll tv = (lower_bound(ps,ps + m,make_pair(W-sw,INF))-1)->second;
            res = max(res,sv + tv);
        }
    }
 
    printf("%lld\n",res);
}
/*
for (int i = 1; i <= n; i++)
    for (int j = w[i]; j <=V; j++)
        f[j] = max(f[j], f[j - w[i]] + v[i]);

*/
```

## LIS

```cpp
int l=b[i],r=b[i+1],cnt=0,x=1,pos=0;
if(l+1==r)continue;
for(int j=l;j<=r;j++)cnt++,f[cnt]=a[j]-cnt;
p[++pos]=f[1];
for(int j=2;j<=cnt;j++){
   x=upper_bound(p+1,p+1+pos,f[j])-p;
   f(x==1)continue;
   p[x]=f[j];
   pos=max(pos,x);
}
ans+=cnt-x;
```



# 计算几何

## n个点确定三角形个数

```cpp
#include <bits/stdc++.h>
#define endl "\n"
using namespace std;
typedef long long ll;
const int MAXN = 2000 + 7;
 
struct Point {
    Point(ll x = 0, ll y = 0) : x(x), y(y){}
    ll x, y;
    Point operator - (const Point &p) const {
        return Point(x - p.x, y - p.y);
    }
    ll operator * (const Point &p) const {      //    dot
        return x * p.x + y * p.y;
    }
    ll operator ^ (const Point &p) const {      //    det
        return x * p.y - y * p.x;
    }
    bool operator < (const Point &p) const {    //   angle sorting
        bool up[2] = {0, 0};
        if(y > 0 || (y == 0 && x > 0)) up[0] = 1;
        if(p.y > 0 || (p.y == 0 && p.x > 0)) up[1] = 1;
        if(up[0] ^ up[1]) return up[0];
        return (*this) ^ p ? ((*this) ^ p) > 0 : ((*this) * (*this)) < (p * p);
    }
}p[2020], vec[4020];
 
int main() {
    ios::sync_with_stdio(false);
    int n;
    while(cin >> n) {
        ll ans = 1LL * n * (n-1) *(n-2) / 6, tmp = 0;
        ll tt=0;
        //  input data starts
        for(int i = 0; i < n; ++i) {
            cin >> p[i].x >> p[i].y;
        }
        //   input data ends
        //  solution start
        for(int i = 0; i < n; ++i) {
            int cnt = 0;
            for(int j = 0; j < n; ++j) {
                if(i == j) continue;
                vec[cnt++] = p[j] - p[i];
            }
            sort(vec, vec + cnt);
            for(int j = 0; j < cnt; ++j) {
                vec[j + cnt] = vec[j];
            }
            ll num = 0;
            for(int j = 1; j < cnt; ++j) {
                if((vec[j] ^ vec[j-1]) == 0 && vec[j] * vec[j-1] > 0) { //   共线
                    num++;
                }
                else num = 0;
                tmp += num;
            }
            int p1 = 0, p2 = 0;
            for(int j = 0; j < cnt; ++j) {
                //  vec[j]逆时针方向锐角数
                while(p1 <= j || (p1 < j + cnt && (vec[p1] ^ vec[j]) < 0 && (vec[p1] * vec[j]) >=0)) p1++;
                //=包含了直角和三点共线 
                //  vec[j]逆时针方向的锐角、直角、钝角数
                while(p2 <= j || (p2 < j + cnt && (vec[p2] ^ vec[j]) < 0)) p2++;
                ans -= p2 - p1;
                tt+=p2-p1;
            }
        }
        //  solution ends
        cout << tt  << endl;
    }
    return 0;
}
//钝角即p2-p1
//直角和锐角即C(n,3)-钝角-三点共线
//锐角即减去C(n,3)-钝角-直角-三点共线 
```

## 半平面交

```cpp
#include<math.h>
#include<stdio.h>
#include<string.h>
#include<algorithm>
#include<iostream> 
using namespace std;
typedef long long ll;
const int maxn=1e5+10;
struct Point{
	double x,y;
};
Point p[maxn],a[maxn],b[maxn],t[maxn];
int n,m;
double A,B,C;
void GetLine(Point a,Point b){//得直线 
	A=b.y-a.y;
	B=a.x-b.x;
	C=b.x*a.y-a.x*b.y;
}
Point interpoint(Point a,Point b){//两直线求交点 
	double x=fabs(A*a.x+B*a.y+C);
	double y=fabs(A*b.x+B*b.y+C);
	Point ans;
	ans.x=(a.x*y+b.x*x)/(x+y);
	ans.y=(a.y*y+b.y*x)/(x+y);
	return ans;
}
void cut(){
	int cnt=0;
	for(int i=1;i<=m;i++){
		if(A*a[i].x+B*a[i].y+C>=0)b[++cnt]=a[i];
		else{
			if(A*a[i-1].x+B*a[i-1].y+C>0)b[++cnt]=interpoint(a[i-1],a[i]);
			if(A*a[i+1].x+B*a[i+1].y+C>0)b[++cnt]=interpoint(a[i],a[i+1]);
		}
	}
	for(int i=1;i<=cnt;i++)a[i]=b[i];
	a[0]=b[cnt];a[cnt+1]=b[1];
	m=cnt;
}
void solve(){
	for(int i=1;i<=n;i++)a[i]=p[i];
	p[n+1]=p[1];a[n+1]=p[1];a[0]=p[n];
	m=n;
	for(int i=1;i<=n;i++){
		GetLine(p[i],p[i+1]);
		cut();
	}
}
void init(){//将点变为逆时针 
	for(int i=1;i<=n;i++)t[i]=p[n-i+1];
	for(int i=1;i<=n;i++)p[i]=t[i];
}
int main(){
	while(~scanf("%d",&n)){
		if(!n)break;
		for(int i=1;i<=n;i++){
			double x,y;
			scanf("%lf%lf",&x,&y);
			p[i].x=x,p[i].y=y;
		}
		init();
		solve();
		if(m)puts("1");
		else puts("0");
	}
	return 0;
}

/*
双端队列求半平面交nlgn 
struct Point{//点的表示 
	double x,y;
	Point(double _x=0,double _y=0){
		x=_x;y=_y;
	}
	friend Point operator + (const Point &a,const Point &b){
		return Point(a.x+b.x,a.y+b.y); 
	}
	friend Point operator - (const Point &a,const Point &b){
		return Point(a.x-b.x,a.y-b.y);
	}
	friend Point operator == (const Point &a,const Point &b){
		return fabs(a.x-b.x)<EPS&&fabs(a.y-b.y)<EPS;
	}
}convex[MAXN];
struct V{//向量的表示 
	Point start,end;
	double ang;//角度，[-180,180] 
	V(Point _start=Point(0,0),Point _end=Point(0,0),double _ang=0){
		start=_start;end=_end;ang=_ang;
	}
	friend V operator + (const V &a,const V &b){
		return V(a.start+b.start,a.end+b.end);
	}
	friend V operator - (const V &a,const V &b){
		return V(a.start-b.start,a.end-b.end);
	} 
}l[MAXN],st[MAXN];
struct Triangle{
	Point A,B,C;
};
int n,ccnt;
double DotMul(V a,V b){//点积 
	a.end=a.end-a.start;b.end=b.end-b.start;
	return a.end.x*b.end.x+a.end.y*b.end.y;
}
double CroMul(V a,V b){//叉积 a×b 
	a.end=a.end-a.start;b.end=b.end-b.start;
	return a.end.x*b.end.y-b.end.x*a.end.y;
}
int IsLineInter(V l1,V l2){//相交 
	if(max(l1.start.x,l1.end.x)>=min(l2.start.x,l2.end.x)&&
	max(l2.start.x,l2.end.x)>=min(l1.start.x,l1.end.x)&&
	max(l1.start.y,l1.end.y)>=min(l2.start.y,l2.end.y)&&
	max(l2.start.y,l2.end.y)>=min(l1.start.y,l1.end.y)){
		if(CroMul(l2,V(l2.start,l1.start))*CroMul(l2,V(l2.start,l1.end))<=0&&
		CroMul(l1,V(l1.start,l2.start))*CroMul(l1,V(l1.start,l2.end))<=0){
			return 1;
		}
	}return 0;
}
Point LineInterDot(V l1,V l2){//交点 
	Point p;
	double S1=CroMul(V(l1.start,l2.end),V(l1.start,l2.start));
	double S2=CroMul(V(l1.end,l2.start),V(l1.end,l2.end));
	p.x=(l1.start.x*S2+l1.end.x*S1)/(S1+S2);
	p.y=(l1.start.y*S2+l1.end.y*S1)/(S1+S2);
	return p;
}
int JudgeOut(const V &x,const Point &p){//点在线的左侧 
	return CroMul(V(x.start,p),x)>EPS;//点在左侧返回0,右侧返回1 
}
int Parellel(const V &x,const V &y){//平行 
	return fabs(CroMul(x,y))<EPS;
}
int Cmp(V a,V b){
	if(fabs(a.ang-b.ang)<EPS){//角度相同时，不同的边在不同的位置 
		//此时有两种return方式， 
		//return CorMul(a,V(b.end-a.start))>=0;
		//左边的边在后面的位置，这样的话，进行计算的时候就可以忽略 相同角度边的影响了 
		return CroMul(V(b.end-a.start),V(a.end-b.start))>EPS;
		//左边的边在前面的位置，要进行进行去重判断 。 
	}
	return a.ang<b.ang;
}
double HplaneIntersection(){
	int top=1,bot=0;
	sort(l,l+n,Cmp);
	int tmp=1;
	for(int i=1;i<n;++i){
		if(l[i].ang-l[i-1].ang>EPS){//去重,如果该边和前面的边平行，则忽略。 
			l[tmp++]=l[i];
		}
	}n=tmp;
	st[0]=l[0];st[1]=l[1];
	for(int i=2;i<n;++i){
		if(Parellel(st[top],st[top-1])||Parellel(st[bot],st[bot+1])) return 0;
		while(bot<top&&JudgeOut(l[i],LineInterDot(st[top],st[top-1]))) --top;
		while(bot<top&&JudgeOut(l[i],LineInterDot(st[bot],st[bot+1]))) ++bot;
		st[++top]=l[i];
	}
	while(bot<top&&JudgeOut(st[bot],LineInterDot(st[top],st[top-1]))) --top;
	while(bot<top&&JudgeOut(st[top],LineInterDot(st[bot],st[bot+1]))) ++bot;
	if(top<=bot+1) return 0.00;
	st[++top]=st[bot];
	ccnt=0;
	for(int i=bot;i<top;++i){
		convex[ccnt++]=LineInterDot(st[i],st[i+1]);
	}double ans=0;
	convex[ccnt]=convex[0];
	for(int i=0;i<ccnt;++i){
		ans+=CroMul(V(Point(0,0),convex[i]),V(Point(0,0),convex[i+1]));
	}return ans/2;
}
*/
```

## 求圆心

```cpp
#include <stdio.h>
#include <iostream>
#include <algorithm>
#include <queue>
#include <map>
using namespace std;
typedef long long ll;
const int N = 1e6 +10;
const double dinf=1e15;
const double eps=1e-6;
int n;
double R;

struct Point{
	double x,y;
	
	Point(double _x=0,double _y=0):x(_x),y(_y) {}
	
	Point operator -(const Point &op2) const {
		return Point(x-op2.x,y-op2.y);
	}
	
	Point operator +(const Point &op2) const {
		return Point(x+op2.x,y+op2.y);
	}
	
	Point operator /(const double d) const {
		return Point(x/d,y/d);
	}
	
	Point operator *(const double d) const{
		return Point(x*d,y*d);
	}
	
	double operator ^(const Point &op2) const {
		return x*op2.y-y*op2.x;
	}	
};
struct StraightLine{
	double A,B,C;
	StraightLine(double _a=0,double _b=0,double _c=0):A(_a),B(_b),C(_c){}
	Point cross(const StraightLine &a) const {
		double xx=-(C*a.B-a.C*B)/(A*a.B-B*a.A);
		double yy=-(C*a.A-a.C*A)/(B*a.A-a.B*A);
		return Point(xx,yy);
	}
};
inline double sqr(double x){
	return x*x;
}

inline double dis2(const Point &p1,const Point &p2){
	return sqr(p1.x-p2.x)+sqr(p1.y-p2.y);
}

inline double dis(const Point &p1,const Point &p2){
	return sqrt(dis2(p1,p2));
}

inline double mul(const Point &p1,const Point &p2,const Point &p3){
	return (p2-p1)^(p3-p1);
}

inline double circumcenter(const Point &p1,const Point &p2,const Point &p3,Point &p){
	p=p1+StraightLine(p3.x-p1.x,p3.y-p1.y,-dis2(p3,p1)/2.0).cross(StraightLine(p2.x-p1.x,p2.y-p1.y,-dis2(p2,p1)/2.0));
	return dis2(p,p1);
}

Point p1,p2,p3,p4,p;
Point pp[10];
int flag=0;
void solve(Point a,Point b,Point c,Point d){//三点共圆求圆心
    double r=circumcenter(a,b,c,p);
    if(fabs(dis2(p,d)-r)<eps)flag=1;
}
int main(){
    int T;
    scanf("%d",&T);
    while(T--){
        for(int i=0;i<4;i++)scanf("%lf%lf",&pp[i].x,&pp[i].y);
        flag=0;
        solve(pp[0],pp[1],pp[2],pp[3]);
        solve(pp[0],pp[1],pp[3],pp[2]);
        solve(pp[0],pp[2],pp[3],pp[1]);
        solve(pp[1],pp[2],pp[3],pp[0]);
        if(flag)puts("yes");
        else puts("no");

    }
    return 0;
}
```

```cpp
//空间四点确定球心坐标（克莱姆法则
void get_xyz(double xa,double ya,double za,
             double xb,double yb,double zb,
             double xc,double yc,double zc,
             double xd,double yd,double zd,
             double &x,double &y,double &z){
    double a11,a12,a13,a21,a22,a23,a31,a32,a33,b1,b2,b3,d,d1,d2,d3;
    a11=2*(xb-xa),a12=2*(yb-ya),a13=2*(zb-za);
    a21=2*(xc-xb),a22=2*(yc-yb),a23=2*(zc-zb);
    a31=2*(xd-xc),a32=2*(yd-yc),a33=2*(zd-zc);
    b1=xb*xb-xa*xa+yb*yb-ya*ya+zb*zb-za*za;
    b2=xc*xc-xb*xb+yc*yc-yb*yb+zc*zc-zb*zb;
    b3=xd*xd-xc*xc+yd*yd-yc*yd+zd*zd-zc*zc;
    d=a11*a22*a33+a12*a23*a31+a13*a21*a32-a11*a23*a32-a12*a21*a33-a13*a22*a31;
    d1=b1*a22*a33+a12*a23*b3+a13*b2*a32-b1*a23*a32-a12*b2*a33-a13*a22*b3;
    d2=a11*b2*a33+b1*a23*a31+a13*a21*b3-a11*a23*b3-b1*a21*a33-a13*b2*a31;
    d3=a11*a22*b3+a12*b2*a31+b1*a21*a32-a11*b2*a32-a12*a21*b3-b1*a22*a31;
    x=d1/d,y=d2/d,z=d3/d;//d==0四点共面
}
```



## 线段直线是否相交

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e5+10;
const int mod=1e9+7;
const int INF=0x3f3f3f3f;
const double eps=1e-6;
ll read(){
    ll f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
struct arr{
	double s1,s2,e1,e2;
}a[maxn];
int n,q;
double cross(arr a,double x,double y){
	return (a.s1-x)*(a.e2-y)-(a.e1-x)*(a.s2-y); 
} 
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%lf%lf%lf%lf",&a[i].s1,&a[i].s2,&a[i].e1,&a[i].e2);
	scanf("%d",&q);
	while(q--){
		double s1,s2,e1,e2;
		int sum=0;
		scanf("%lf%lf%lf%lf",&s1,&s2,&e1,&e2);
		for(int i=1;i<=n;i++)
			if(cross(a[i],s1,s2)*cross(a[i],e1,e2)>eps)continue;
			else sum++;
		if(sum%2)puts("different");
		else puts("same");
	} 
	return 0;
}
```

## 圆的面积并

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;
const double eps = 1e-8;
const double pi = acos(-1.0);
const int maxn = 1e6+10;
struct Tpoint{
    double x,y;
};
typedef pair<double,double> pdd;
pdd now[maxn];
struct Tcircle{
    Tpoint p;
    double r;
};

Tpoint operator -(Tpoint x,Tpoint y){
    Tpoint tmp;
    tmp.x = x.x-y.x;tmp.y = x.y-y.y;
    return tmp;
}
Tpoint operator +(Tpoint x,Tpoint y){
    Tpoint tmp;
    tmp.x = x.x+y.x;tmp.y = x.y+y.y;
    return tmp;
}
Tpoint operator *(Tpoint x,double d){
    Tpoint tmp ;
    tmp.x = x.x*d;tmp.y = x.y*d;
    return tmp;
}
Tpoint operator /(Tpoint x,double d){
    Tpoint tmp ;
    tmp.x = x.x/d;tmp.y = x.y/d;
    return tmp;
}
double operator *(Tpoint x,Tpoint y){
    return x.x*y.x + x.y*y.y;
}
double operator ^(Tpoint x,Tpoint y){
    return x.x*y.y-x.y*y.x;
}
double dis0(Tpoint a){
    return sqrt(a.x*a.x+a.y*a.y);
}

int sign(double k){
    if(fabs(k) < eps)  return 0;
    return k > 0 ? 1:-1;
}

double getpoint(Tpoint ap,double ar,Tpoint bp,double br){
    double d = dis0(ap-bp);
    double cos_t = (ar*ar+d*d-br*br)/(2*ar*d);
    return cos_t;
}
int m,n;
Tcircle tcin[maxn],c[maxn];

void uni(){
    n=0;
    for(int i=1;i<=m;i++){
        bool covered=false;
        for(int j=1;j<=m;j++) if(i!=j){
            int tmpr=sign(tcin[j].r-tcin[i].r);
            int tmp=sign(dis0(tcin[i].p-tcin[j].p)-(tcin[j].r-tcin[i].r));
            if(tmp<=0){
                if(tmpr>0 || (tmpr==0&&j<i)) covered=true;
            }
        }
        if(!covered) c[++n]=tcin[i];
    }
}
double to_2pi(double x){
    if(x < 0)   return x+2*pi;
    else    return x;
}
void sov(){
    double ans = 0;
    for(int i = 1 ; i <= n ; i++){
        int cnt = 0;double a = c[i].p.x,b = c[i].p.y,r = c[i].r;
        for(int j = 1 ; j <= n ; j++){
            if(i == j) continue;
            if(sign(dis0(c[i].p-c[j].p)-(c[i].r+c[j].r)) >= 0) continue;
            double cos_t = getpoint(c[i].p,c[i].r,c[j].p,c[j].r);
            double stad,angle1,angle2;
            stad = atan2((c[j].p-c[i].p).y,(c[j].p-c[i].p).x);
            angle1 = to_2pi(stad - acos(cos_t));
            angle2 = to_2pi(stad + acos(cos_t));
            if(sign(angle2-angle1) >= 0){
                now[cnt++] = make_pair(angle1 , angle2);
            }
            else{
                now[cnt++] = make_pair(0.0 , angle2);
                now[cnt++] = make_pair(angle1 , 2*pi);
            }
        }

        sort(now,now+cnt);
        double right = 0;
        for(int k = 0 ; k < cnt ; k++){
            if(now[k].first > right){
                double low = right, up = now[k].first;
                ans += 0.5*r*r*(up-low) + 0.5*r*(a*(sin(up)-sin(low))-b*(cos(up)-cos(low)));
            }
            right = fmax(right , now[k].second);
        }
        double low = right,up = 2*pi;
        ans += 0.5*r*r*(up-low) + 0.5*r*(a*(sin(up)-sin(low))-b*(cos(up)-cos(low)));
    }
    printf("%.3f\n",ans);
}

int main(){
    scanf("%d",&m);
    for(int i = 1; i <= m; i++)
        scanf("%lf%lf%lf",&tcin[i].p.x,&tcin[i].p.y,&tcin[i].r);
    uni();
    sov();
}
```

## 圆和矩形的面积交

```cpp
#include<bits/stdc++.h>
using namespace std;  
#define INF 0x3f3f3f3f  
#define eps 1e-17  
#define pi acos(-1.0)  
typedef long long ll;  
int dcmp(double x){  
    if(fabs(x)<eps)return 0;  
    return x>0?1:-1;  
}  
struct Point{  
    double x,y;  
    Point(double _x=0,double _y=0){  
        x=_x;y=_y;  
    }  
};  
Point operator + (const Point &a,const Point &b){  
    return Point(a.x+b.x,a.y+b.y);  
}  
Point operator - (const Point &a,const Point &b){  
    return Point(a.x-b.x,a.y-b.y);  
}  
Point operator * (const Point &a,const double &p){  
    return Point(a.x*p,a.y*p);  
}  
Point operator / (const Point &a,const double &p){  
    return Point(a.x/p,a.y/p);  
}  
bool operator < (const Point &a,const Point &b){  
    return a.x<b.x||(dcmp(a.x-b.x)==0&&a.y<b.y);  
}  
bool operator == (const Point &a,const Point &b){  
    return dcmp(a.x-b.x)==0&&dcmp(a.y-b.y)==0;  
}  
double Dot(Point  a,Point b){  
    return a.x*b.x+a.y*b.y;  
}  
double Length(Point a){  
    return sqrt(Dot(a,a));  
}  
double Angle(Point a,Point b){  
    return acos(Dot(a,b)/Length(a)/Length(b));  
}  
double angle(Point a){  
    return atan2(a.y,a.x);  
}  
double Cross(Point a,Point b){  
    return a.x*b.y-a.y*b.x;  
}  
Point vecunit(Point a){  
    return a/Length(a);  
}  
Point Normal(Point a){  
    return Point(-a.y,a.x)/Length(a);  
}  
Point Rotate(Point a,double rad){  
    return Point(a.x*cos(rad)-a.y*sin(rad),a.x*sin(rad)+a.y*cos(rad));  
}  
double Area2(Point a,Point b,Point c){  
    return Length(Cross(b-a,c-a));  
}  
bool OnSegment(Point p,Point a1,Point a2){    
    return dcmp(Cross(a1-p,a2-p))==0&&dcmp(Dot(a1-p,a2-p))<=0;    
}    
struct Line{  
    Point p,v;  
    double ang;  
    Line(){};  
    Line(Point p,Point v):p(p),v(v){  
        ang=atan2(v.y,v.x);  
    }  
    bool operator < (const Line &L) const {  
        return ang<L.ang;  
    }  
    Point point(double d){  
        return p+(v*d);  
    }  
};  
bool OnLeft(const Line &L,const Point &p){  
    return Cross(L.v,p-L.p)>=0;  
}  
Point GetLineIntersection(Point p,Point v,Point q,Point w){  
    Point u=p-q;  
    double t=Cross(w,u)/Cross(v,w);  
    return p+v*t;  
}  
Point GetLineIntersection(Line a,Line b){  
    return GetLineIntersection(a.p,a.v,b.p,b.v);  
}  
double PolyArea(vector<Point> p){  
    int n=p.size();  
    double ans=0;  
    for(int i=1;i<n-1;i++)  
        ans+=Cross(p[i]-p[0],p[i+1]-p[0]);  
    return fabs(ans)/2;  
}  
struct Circle{      
    Point c;      
    double r;      
    Circle(){}      
    Circle(Point c, double r):c(c), r(r){}      
    Point point(double a) {//根据圆心角求点坐标          
        return Point(c.x+cos(a)*r, c.y+sin(a)*r);      
    }      
};     
    
bool InCircle(Point x,Circle c){    
    return dcmp(c.r-Length(c.c-x))>=0;    
}    
bool OnCircle(Point x,Circle c){    
    return dcmp(c.r-Length(c.c-x))==0;    
}    
int getSegCircleIntersection(Line L,Circle C,Point *sol){    
    Point nor=Normal(L.v);    
    Line p1=Line(C.c,nor);    
    Point ip=GetLineIntersection(p1,L);    
    double dis=Length(ip-C.c);    
    if(dcmp(dis-C.r)>0)return 0;    
    Point dxy=vecunit(L.v)*sqrt(C.r*C.r-dis*dis);    
    int ret=0;    
    sol[ret]=ip+dxy;    
    if(OnSegment(sol[ret],L.p,L.point(1)))ret++;    
    sol[ret]=ip-dxy;    
    if(OnSegment(sol[ret],L.p,L.point(1)))ret++;    
    return ret;    
}    
double SegCircleArea(Circle C,Point a,Point b){    
    double a1=angle(a-C.c);    
    double a2=angle(b-C.c);    
    double da=fabs(a1-a2);    
    if(da>pi)da=pi*2-da;    
    return dcmp(Cross(b-C.c,a-C.c))*da*C.r*C.r/2.0;    
}    
double PolyCircleArea(Circle C,Point *p,int n){    
    double ret=0;    
    Point sol[2];    
    p[n]=p[0];    
    for(int i=0;i<n;i++){    
        double t1,t2;    
        int cnt=getSegCircleIntersection(Line(p[i],p[i+1]-p[i]),C,sol);  //判断线段与圆有几个交点，  
        if(cnt==0){  //0个交点，判断线段在多边形内部还是外部。  
            if(!InCircle(p[i],C)||!InCircle(p[i+1],C))ret+=SegCircleArea(C,p[i],p[i+1]); //外部直接计算圆弧面积   
            else ret+=Cross(p[i+1]-C.c,p[i]-C.c)/2;  //内部计算三角形面积。  
        }    
        if(cnt==1){    
            if(InCircle(p[i],C)&&(!InCircle(p[i+1],C)||OnCircle(p[i+1],C)))ret+=Cross(sol[0]-C.c,p[i]-C.c)/2,ret+=SegCircleArea(C,sol[0],p[i+1]);//,cout<<"jj-1"<<endl;  
            else ret+=SegCircleArea(C,p[i],sol[0]),ret+=Cross(p[i+1]-C.c,sol[0]-C.c)/2;//,cout<<"jj-2"<<endl;  
        }    
        if(cnt==2){
            if((p[i]<p[i+1])^(sol[0]<sol[1]))swap(sol[0],sol[1]);    
            ret+=SegCircleArea(C,p[i],sol[0]);    
            ret+=Cross(sol[1]-C.c,sol[0]-C.c)/2;    
            ret+=SegCircleArea(C,sol[1],p[i+1]);    
        }       
    }    
    return fabs(ret);    
}    
int main()    {     
    Point p[5];
	int t, cas = 1;    
    double R;    
    double x1,y1,x2,y2,x3,y3;    
    bool flag=0;  
    while(cin>>x1>>y1>>R>>x2>>y2>>x3>>y3){    
        Circle C=Circle(Point(x1,y1),R);    
        if(x2>x3)swap(x2,x3);  
        if(y2>y3)swap(y2,y3);  
        p[0]=Point(x2,y2);    
		p[2]=Point(x3,y3);    
        p[1]=Point(x3,y2);    
        p[3]=Point(x2,y3);    
        double ans=PolyCircleArea(C,p,4);  
        if(ans < -eps) ans = -ans;
		printf("%.4lf\n",ans);         
    }  
     return 0;    
}  
```

## 圆和正方形交点个数

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e5+10;
const int mod=1e9+7;
const int INF=0x3f3f3f3f;
ll read(){
    ll f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
int round_x,round_y,round_r;
int ts_x,ts_y,ts_len;
bool pInC(int x,int y,int r,int dx,int dy){
	int ddx = dx - x;
	int ddy = dy - y;
	return ddx * ddx + ddy * ddy < r * r;
}
bool pInS(int X, int Y, int len, int x, int y) {
	if(x>X && x<X+len && y>Y && y<Y+len)return 1;
	return 0;
}
bool cover(){
	if(pInC(round_x,round_y,round_r,ts_x,ts_y))return 1;
	if(pInC(round_x,round_y,round_r,ts_x+ts_len,ts_y))return 1;
	if(pInC(round_x,round_y,round_r,ts_x,ts_y+ts_len))return 1;
	if(pInC(round_x,round_y,round_r,ts_x+ts_len,ts_y+ts_len))return 1;
	if(pInS(ts_x,ts_y,ts_len,round_x-round_r,round_y))return 1;
	if(pInS(ts_x,ts_y,ts_len,round_x+round_r,round_y))return 1;
	if(pInS(ts_x,ts_y,ts_len,round_x,round_y-round_r))return 1;
	if(pInS(ts_x,ts_y,ts_len,round_x,round_y+round_r))return 1;
	if(pInS(ts_x,ts_y,ts_len,round_x,round_y))return 1;
	return 0;
}
bool pOnC(int x,int y,int r,int X,int Y){
	int dx=X-x,dy=Y-y;
	return dx*dx+dy*dy==r*r; 
} 
bool pOnS(int X,int Y,int len,int x,int y){
	if(x==X && y>=Y && y<=Y+len)return 1;
	if(x==X+len && y>=Y && y<=Y+len)return 1;
	if(x>=X && x<=X+len && y==Y)return 1;
	if(x>=X && x<=X+len && y==Y+len)return 1;
	return 0;
}
bool touch(){
	if(pOnC(round_x,round_y,round_r,ts_x,ts_y))return 1;
	if(pOnC(round_x,round_y,round_r,ts_x+ts_len,ts_y))return 1;
	if(pOnC(round_x,round_y,round_r,ts_x,ts_y+ts_len))return 1;
	if(pOnC(round_x,round_y,round_r,ts_x+ts_len,ts_y+ts_len))return 1;
	if(pOnS(ts_x,ts_y,ts_len,round_x-round_r,round_y))return 1;
	if(pOnS(ts_x,ts_y,ts_len,round_x+round_r,round_y))return 1;
	if(pOnS(ts_x,ts_y,ts_len,round_x,round_y-round_r))return 1;
	if(pOnS(ts_x,ts_y,ts_len,round_x,round_y+round_r))return 1;
	return 0;
}
int main(){
	scanf("%d%d%d",&round_x,&round_y,&round_r);
	scanf("%d%d%d",&ts_x,&ts_y,&ts_len);
	if (cover())puts("2");
	else if(touch())puts("1");
	else puts("0");
	return 0;
}
```

# 数据结构

## 树

### 求树的重心

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e6+10;
const int mod=1e9+7;
const int INF=0x3f3f3f3f;
ll read(){
    ll f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
int n,ans,size=INF;
vector<int>G[maxn];
int son[maxn],vis[maxn];
void dfs(int cur){
	vis[cur]=1;
	son[cur]=0;
	int tmp=0;
	for(int i=0;i<G[cur].size();i++){
		int u=G[cur][i];
		if(!vis[u]){
			dfs(u);
			son[cur]+=son[u]+1;
			tmp=max(tmp,son[u]+1); 
		}
	}
	tmp=max(tmp,n-son[cur]-1);
	if(tmp<size || tmp==size && cur<ans){
		ans=cur;
		size=tmp;
	}
}
ll sum=0;
void dfs2(int x,int fa,int dep){
	for(int i=0;i<G[x].size();i++){
		int u=G[x][i];
		if(u==fa)continue;
		dfs2(u,x,dep+1);
	}
	sum=sum+1ll*dep;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		G[u].push_back(v);
		G[v].push_back(u);
	}
	dfs(1); 
	dfs2(ans,-1,0);
	printf("%lld\n",sum);
	return 0;
}
```

### 倍增法求LCA

```cpp
#include "stdio.h"
#include "string.h"
#include "iostream"
#include "algorithm"
#include "vector"
using namespace std;
const int maxn=1e4+10;
vector<int>G[maxn];
int n,cnt;
int head[maxn],d[maxn],in[maxn],f[maxn][31];//f[x][y]表示x向上i跳2^y步的祖先节点
void dfs(int pos,int fa){
    d[pos]=d[fa]+1;//d代表深度
    f[pos][0]=fa;
    for(int i=0;i<=19;i++)
        f[pos][i+1]=f[f[pos][i]][i];
    for(int i=0;i<G[pos].size();i++){
        int u=G[pos][i];
        if(u==fa)continue;
        //dis[u]=dis[pos]+edge[i].v; 
        f[u][0]=pos;
        dfs(u,pos);
    }
}//dfs预处理f数组
int LCA(int x,int y){
    if(d[x]<d[y])swap(x,y);
    for(int i=20;i>=0;i--){
        if(d[f[x][i]]>=d[y])x=f[x][i];
        if(x==y)return x;
    }//保持x和y在同一深度
    for(int i=20;i>=0;i--)
        if(f[x][i]!=f[y][i])x=f[x][i],y=f[y][i];
    return f[x][0];
}
int main(){
    int T;
    scanf("%d",&T);
    while(T--){
        scanf("%d",&n);
        memset(in,0,sizeof(in));
        memset(f,0,sizeof(f));
        memset(d,0,sizeof(d));d[0]=-1;
        for(int i=1;i<=n;i++)G[i].clear();
        for(int i=1;i<n;i++){
            int x,y;
            scanf("%d%d",&x,&y);
            G[x].push_back(y);
            f[y][0]=x; in[y]++;
        }
        int node;
        for(int i=1;i<=n;i++)
        	if(!in[i]){
        		node=i;
        		break;
			}
        dfs(node,0);
        int u,v;
        scanf("%d%d",&u,&v);
        printf("%d\n",LCA(u,v));
    }
    return 0;
}
```

### 树链剖分

![image-20201016151041364](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201016151041364.png)

![image-20201016151054660](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201016151054660.png)

```cpp
const int maxn=1e5+10;
struct edge{
    int next,to;
}e[2*maxn];
struct Node{
    int sum,lazy,l,r,ls,rs;
}node[2*maxn];
int rt,n,m,r,a[maxn],cnt,head[maxn],f[maxn],d[maxn],size[maxn],son[maxn],rk[maxn],top[maxn],id[maxn];
```

![image-20201016151140894](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201016151140894.png)

![image-20201016151155098](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201016151155098.png)

![image-20201016151210327](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201016151210327.png)

```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
const int maxn=1e5+10;
struct edge{
    int next,to;
}e[maxn*2];
struct node{
    int l,r,ls,rs,sum,lazy;
}a[maxn*2];
int n,m,r,rt,mod,v[maxn],head[maxn],cnt,f[maxn],d[maxn],son[maxn],size[maxn],top[maxn],id[maxn],rk[maxn];
void add(int x,int y)
{
    e[++cnt].next=head[x];
    e[cnt].to=y;
    head[x]=cnt;
}
void dfs1(int x)
{
    size[x]=1,d[x]=d[f[x]]+1;
    for(int v,i=head[x];i;i=e[i].next)
        if((v=e[i].to)!=f[x])
        {
            f[v]=x,dfs1(v),size[x]+=size[v];
            if(size[son[x]]<size[v])
                son[x]=v;
        }
}
void dfs2(int x,int tp)
{
    top[x]=tp,id[x]=++cnt,rk[cnt]=x;
    if(son[x])
        dfs2(son[x],tp);
    for(int v,i=head[x];i;i=e[i].next)
        if((v=e[i].to)!=f[x]&&v!=son[x])
            dfs2(v,v);
}
inline void pushup(int x)
{
    a[x].sum=(a[a[x].ls].sum+a[a[x].rs].sum)%mod;
}
void build(int l,int r,int x)
{
    if(l==r)
    {
        a[x].sum=v[rk[l]],a[x].l=a[x].r=l;
        return;
    }
    int mid=l+r>>1;
    a[x].ls=cnt++,a[x].rs=cnt++;
    build(l,mid,a[x].ls),build(mid+1,r,a[x].rs);
    a[x].l=a[a[x].ls].l,a[x].r=a[a[x].rs].r;
    pushup(x);
}
inline int len(int x)
{
    return a[x].r-a[x].l+1;
}
inline void pushdown(int x)
{
    if(a[x].lazy)
    {
        int ls=a[x].ls,rs=a[x].rs,lz=a[x].lazy;
        (a[ls].lazy+=lz)%=mod,(a[rs].lazy+=lz)%=mod;
        (a[ls].sum+=lz*len(ls))%=mod,(a[rs].sum+=lz*len(rs))%=mod;
        a[x].lazy=0;
    }
}
void update(int l,int r,int c,int x)
{
    if(a[x].l>=l&&a[x].r<=r)
    {
        (a[x].lazy+=c)%=mod,(a[x].sum+=len(x)*c)%=mod;
        return;
    }
    pushdown(x);
    int mid=a[x].l+a[x].r>>1;
    if(mid>=l)
        update(l,r,c,a[x].ls);
    if(mid<r)
        update(l,r,c,a[x].rs);
    pushup(x);
}
int query(int l,int r,int x)
{
    if(a[x].l>=l&&a[x].r<=r)
        return a[x].sum;
    pushdown(x);
    int mid=a[x].l+a[x].r>>1,tot=0;
    if(mid>=l)
        tot+=query(l,r,a[x].ls);
    if(mid<r)
        tot+=query(l,r,a[x].rs);
    return tot%mod;
}
inline int sum(int x,int y)
{
    int ret=0;
    while(top[x]!=top[y])
    {
        if(d[top[x]]<d[top[y]])
            swap(x,y);
        (ret+=query(id[top[x]],id[x],rt))%=mod;
        x=f[top[x]];
    }
    if(id[x]>id[y])
        swap(x,y);
    return (ret+query(id[x],id[y],rt))%mod;
}
inline void updates(int x,int y,int c)
{
    while(top[x]!=top[y])
    {
        if(d[top[x]]<d[top[y]])
            swap(x,y);
        update(id[top[x]],id[x],c,rt);
        x=f[top[x]];
    }
    if(id[x]>id[y])
        swap(x,y);
    update(id[x],id[y],c,rt);
}
signed main()
{
    scanf("%lld%lld%lld%lld",&n,&m,&r,&mod);
    for(int i=1;i<=n;i++)
        scanf("%lld",&v[i]);
    for(int x,y,i=1;i<n;i++)
    {
        scanf("%lld%lld",&x,&y);
        add(x,y),add(y,x);
    }
    cnt=0,dfs1(r),dfs2(r,r);
    cnt=0,build(1,n,rt=cnt++);
    for(int op,x,y,k,i=1;i<=m;i++)
    {
        scanf("%lld",&op);
        if(op==1)
        {
            scanf("%lld%lld%lld",&x,&y,&k);
            updates(x,y,k);
        }
        else if(op==2)
        {
            scanf("%lld%lld",&x,&y);
            printf("%lld\n",sum(x,y));
        }
        else if(op==3)
        {
            scanf("%lld%lld",&x,&y);
            update(id[x],id[x]+size[x]-1,y,rt);
        }
        else
        {
            scanf("%lld",&x);
            printf("%lld\n",query(id[x],id[x]+size[x]-1,rt));
        }
    }
    return 0;
}
/*
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
const int maxn=1e5+10;
struct edge{
    int next,to;
}e[2*maxn];
struct Node{
    int l,r,ls,rs,sum,lazy;
}node[2*maxn];
int rt,n,m,cnt,head[maxn];
int f[maxn],d[maxn],size[maxn],son[maxn],rk[maxn],top[maxn],tid[maxn];
int readn()
{
    int x=0;
    char ch=getchar();
    while(ch<'0'||ch>'9')
        ch=getchar();
    while(ch>='0'&&ch<='9')
    {
        x=(x<<1)+(x<<3)+ch-'0';
        ch=getchar();
    }
    return x;
}
void add_edge(int x,int y)
{
    e[++cnt].next=head[x];
    e[cnt].to=y;
    head[x]=cnt;
}
void dfs1(int u,int fa,int depth)
{
    f[u]=fa;
    d[u]=depth;
    size[u]=1;
    for(int i=head[u];i;i=e[i].next)
    {
        int v=e[i].to;
        if(v==fa)
            continue;
        dfs1(v,u,depth+1);
        size[u]+=size[v];
        if(size[v]>size[son[u]]||!son[u])
            son[u]=v;
    }
}
void dfs2(int u,int t)
{
    top[u]=t;
    tid[u]=++cnt;
    rk[cnt]=u;
    if(!son[u])
        return;
    dfs2(son[u],t);
    for(int i=head[u];i;i=e[i].next)
    {
        int v=e[i].to;
        if(v!=son[u]&&v!=f[u])
            dfs2(v,v);
    }
}
void pushup(int x)
{
    int lson=node[x].ls,rson=node[x].rs;
    node[x].sum=node[lson].sum+node[rson].sum;
    node[x].l=node[lson].l;
    node[x].r=node[rson].r;
}
void build(int li,int ri,int cur)
{
    if(li==ri)
    {
        node[cur].ls=node[cur].rs=node[cur].lazy=-1;
        node[cur].l=node[cur].r=li;
        return;
    }
    int mid=(li+ri)>>1;
    node[cur].ls=cnt++;
    node[cur].rs=cnt++;
    build(li,mid,node[cur].ls);
    build(mid+1,ri,node[cur].rs);
    pushup(cur);
}
void pushdown(int x)
{
    int lson=node[x].ls,rson=node[x].rs;
    node[lson].sum=node[x].lazy*(node[lson].r-node[lson].l+1);
    node[rson].sum=node[x].lazy*(node[rson].r-node[rson].l+1);
    node[lson].lazy=node[x].lazy;
    node[rson].lazy=node[x].lazy;
    node[x].lazy=-1;
}
void update(int li,int ri,int c,int cur)
{
    if(li<=node[cur].l&&node[cur].r<=ri)
    {
        node[cur].sum=c*(node[cur].r-node[cur].l+1);
        node[cur].lazy=c;
        return;
    }
    if(node[cur].lazy!=-1)
        pushdown(cur);
    int mid=(node[cur].l+node[cur].r)>>1;
    if(li<=mid)
        update(li,ri,c,node[cur].ls);
    if(mid<ri)
        update(li,ri,c,node[cur].rs);
    pushup(cur);
}
int query(int li,int ri,int cur)
{
    if(li<=node[cur].l&&node[cur].r<=ri)
        return node[cur].sum;
    if(node[cur].lazy!=-1)
        pushdown(cur);
    int tot=0;
    int mid=(node[cur].l+node[cur].r)>>1;
    if(li<=mid)
        tot+=query(li,ri,node[cur].ls);
    if(mid<ri)
        tot+=query(li,ri,node[cur].rs);
    return tot;
}
int sum(int x)
{
    int ans=0;
    int fx=top[x];
    while(fx)
    {
        ans+=tid[x]-tid[fx]-query(tid[fx],tid[x],rt)+1;
        update(tid[fx],tid[x],1,rt);
        x=f[fx];
        fx=top[x];
    }
    ans+=tid[x]-tid[0]-query(tid[0],tid[x],rt)+1;
    update(tid[0],tid[x],1,rt);
    return ans;
}
signed main()
{
    n=readn();
    for(int i=1;i<n;i++)
    {
        int x=readn();
        add_edge(x,i);
        add_edge(i,x);
    }
    cnt=0;
    dfs1(0,-1,1);
    dfs2(0,0);
    cnt=0;
    rt=cnt++;
    build(1,n,rt);
    m=readn();
    for(int i=1;i<=m;i++)
    {
        int x;
        string op;
        cin>>op;
        x=readn();
        if(op=="install")
            printf("%lld\n",sum(x));
        else if(op=="uninstall")
        {
            printf("%lld\n",query(tid[x],tid[x]+size[x]-1,rt));
            update(tid[x],tid[x]+size[x]-1,0,rt);
        }
    }
    return 0;
}
/*
1，install x：表示安装软件包x

2，uninstall x：表示卸载软件包x

对于操作一，我们可以统计x到根节点未安装的软件包的个数，然后区间修改为已安装

对于操作二，我们可以统计x所在子树已安装软件包的个数，然后将子树修改为未安装
*/
*/
```

## 树状数组

### 单点修改区间求和

```cpp
#include "stdio.h"
#include "string.h"
#include "iostream"
#include "algorithm"
typedef long long LL;
using namespace std;
const int maxn = 1e5+10;
int n,m,a[maxn*5];
int f[maxn*5],t,x,y;
inline int lowbit(int x){
    return x&-x;
}
inline void add(int x,int k){
    for(int i=x;i<=n;i+=lowbit(i))f[i]+=k;
}
inline int find(int x){
    int ans=0;
    for(int i=x;i>0;i-=lowbit(i))ans+=f[i];
    return ans;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)add(i,a[i]);
    while(m--){
        scanf("%d%d%d",&t,&x,&y);
        if(t==1)add(x,y);
        else printf("%d\n",find(y)-find(x-1));
    }
    return 0;
}
```

### 区间修改单点查询

```cpp
#include "stdio.h"
#include "string.h"
#include "iostream"
#include "algorithm"
typedef long long LL;
using namespace std;
const int maxn = 1e5+10;
LL n,m,a[maxn*5];
LL f[maxn*5],t,x,y,k;
inline LL lowbit(LL x){
    return x&-x;
}
inline void add(LL x,LL k){
    for(LL i=x;i<=n;i+=lowbit(i))f[i]+=k;
}
inline LL find(LL x){
    LL ans=0;
    for(LL i=x;i>0;i-=lowbit(i))ans+=f[i];
    return ans;
}
int main(){
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
    while(m--){
        scanf("%lld",&t);
        if(t==1){
            scanf("%lld%lld%lld",&x,&y,&k);
            add(x,k);add(y+1,-k);
        }else{
            scanf("%lld",&x);
            printf("%lld\n",a[x]+find(x));
        }
    }
    return 0;
}//差分思想
```

### 区间修改区间查询

```cpp
#include "stdio.h"
#include "string.h"
#include "iostream"
#include "algorithm"
typedef long long LL;
using namespace std;
const int maxn = 1e5+10;
LL n,m,a[maxn*5];
LL f1[maxn*5],f2[maxn],t,x,y,k;
inline LL lowbit(LL x){
    return x&-x;
}
inline void add(LL x,LL k){
    for(LL i=x;i<=n;i+=lowbit(i))f1[i]+=k,f2[i]+=k*x;
}
inline LL find(LL x){
    LL ans=0;
    for(LL i=x;i>0;i-=lowbit(i))ans+=(x+1)*f1[i]-f2[i];
    return ans;
}
int main(){
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
    for(int i=1;i<=n;i++)add(i,a[i]-a[i-1]);
    while(m--){
        scanf("%lld",&t);
        if(t==1){
            scanf("%lld%lld%lld",&x,&y,&k);
            add(x,k);add(y+1,-k);
        }else{
            scanf("%lld%lld",&x,&y);
            printf("%lld\n",find(y)-find(x-1));
        }
    }
    return 0;
}
```

### 求逆序对数量

```cpp
#include "stdio.h"
#include "string.h"
#include "iostream"
#include "algorithm"
typedef long long LL;
using namespace std;
const int maxn = 1e5+10;
LL n,m,a[maxn*5],ans;
LL f[maxn*5],f1[maxn*5],f2[maxn],t,x,y,k;
inline LL lowbit(LL x){
    return x&-x;
}
inline void add(LL x,LL k){
    for(LL i=x;i<=n;i+=lowbit(i))f[i]+=k;
}
inline LL find(LL x){
    LL ans=0;
    for(LL i=x;i>0;i-=lowbit(i))ans+=f[i];
    return ans;
}
int main(){
    scanf("%lld",&n);
    for(LL i=1;i<=n;i++){
        scanf("%lld",&x);
        add(x,1);
        ans+=i-find(x);
    }
    printf("%lld\n",ans);
    return 0;
}
```

## 线段树

###          正常线段树

```cpp
//区间加法 单点修改 区间最大 区间最小 区间求和  
#include<bits/stdc++.h>
#define N 100003
using namespace std;
typedef long long LL;
struct arr{
    LL sum;LL maxnum;LL lazy;
}s[N*5];
LL L,R,X,n,m,i,a[N],op;
void pushup(LL node){
    s[node].maxnum=max(s[node<<1].maxnum,s[node<<1|1].maxnum);
    s[node].sum=s[node<<1].sum+s[node<<1|1].sum;
}
void build(LL node,LL l,LL r){
    LL mid=(l+r)>>1;
    if(l==r){
        s[node].maxnum=a[l];
        s[node].sum=a[l];
        s[node].lazy=0;
        return ;
    }
    build(node<<1,l,mid) ;
    build(node<<1|1,mid+1,r);
    pushup(node);
}
void update_one(LL  L,LL X,LL l,LL r,LL node){
    if(l==r){
        s[node].maxnum=X;
        s[node].sum=X;
        return;
    }
    LL mid=(l+r)>>1;
    if(L<=mid)update_one(L,X,l,mid,node<<1);
    else update_one(L,X,mid+1,r,node<<1|1);
    pushup(node);
}
LL query(LL L,LL R,LL l,LL r,LL node){
    if(L<=l && r<=R)return s[node].sum;
    push_lazy(l,r,node);
    LL mid=(l+r)>>1;
    LL ans=0,minn=0x3f3f3f3f;
    if(L<=mid)ans+=query(L,R,l,mid,node<<1);//minn=min(minn,query();
    if(R>mid)ans+=query(L,R,mid+1,r,node<<1|1);
    return ans;
}
void mod_zone(LL L,LL R,LL X,LL l,LL r,LL node){
    if(s[node].maxnum<X)return;
    if(l==r){
        s[node].sum%=X;
        s[node].maxnum%=X;
        return;
    }
    LL mid=(l+r)>>1;
    if(L<=mid)mod_zone(L,R,X,l,mid,node<<1);
    if(R>mid)mod_zone(L,R,X,mid+1,r,node<<1|1);
    pushup(node);
}
void addlazy(LL l,LL r,LL X,LL node){
    s[node].sum+=X*(r-l+1);
    s[node].lazy+=X;
}
void push_lazy(LL l,LL r,LL node){
    if(s[node].lazy){
        LL mid=(l+r)>>1;
        addlazy(l,mid,s[node].lazy,node<<1) ;
        addlazy(mid+1,r,s[node].lazy,node<<1|1);
        s[node].lazy=0;
    }
}
void update_zone(LL L,LL R,LL X,LL l,LL r,LL node){
    if(L<=l && R>=r){
        addlazy(l,r,X,node);
        return ;
    }
    push_lazy(l,r,node);
    LL mid=(l+r)>>1;
    if(L<=mid)update_zone(L,R,X,l,mid,node<<1);
    if(mid<R)update_zone(L,R,X,mid+1,r,node<<1|1);
    pushup(node);
}
int main(){
    scanf("%lld%lld",&n,&m);
    for(i=1;i<=n;i++)scanf("%lld",&a[i]);
    build(1,1,n);
    for(i=1;i<=m;i++){
        scanf("%lld",&op);
        if(op==1){
            scanf("%lld%lld",&L,&R);
            printf("%lld\n",query(L,R,1,n,1));
        }
        if(op==3){
            scanf("%lld%lld",&L,&X);
            update_one(L,X,1,n,1);
        }
        if(op==2){
            scanf("%lld%lld%lld",&L,&R,&X);
            mod_zone(L,R,X,1,n,1);
        }
    }
return 0;}
```

### 线段树区间加法和乘法

```cpp
//区间加法 区间乘法同时
#include "stdio.h"
#include "string.h"
#include "iostream"
#include "algorithm"
typedef long long LL;
#define ls o<<1
#define rs o<<1|1
#define M ((L+R)>>1)
using namespace std;
const int maxn = 100010;
LL n, m, p;
LL A[maxn], sumv[maxn*4], addv[maxn*4], mulv[maxn*4];
LL add(LL a,LL b) {//方便取模
    return (a+b)%p;
}
LL mul(LL a,LL b) {
    return (a*b)%p;
}
inline void build(LL o,LL L,LL R) {
    mulv[o] = 1;
    if(L == R) sumv[o] = A[L] % p;
    else {
        build(ls,L,M);
        build(rs,M+1,R);
        sumv[o] = add(sumv[ls],sumv[rs]);
    }
}
inline void pushdown(LL o,LL L,LL R) {//划重点
    sumv[ls] = mul(sumv[ls],mulv[o]);
    sumv[rs] = mul(sumv[rs],mulv[o]);
    sumv[ls] = add(sumv[ls],addv[o]*(M-L+1));
    sumv[rs] = add(sumv[rs],addv[o]*(R-M));
    mulv[ls] = mul(mulv[ls],mulv[o]);
    mulv[rs] = mul(mulv[rs],mulv[o]);
    addv[ls] = mul(addv[ls],mulv[o]);
    addv[rs] = mul(addv[rs],mulv[o]);
    addv[ls] = add(addv[ls],addv[o]);
    addv[rs] = add(addv[rs],addv[o]);
    addv[o] = 0;
    mulv[o] = 1;
}
LL ql,qr,qa,qm;
inline void updatea(LL o,LL L,LL R) {
    if(ql <= L &&  R <= qr) {
        addv[o] = add(addv[o],qa);
        sumv[o] = add(sumv[o],qa*(R-L+1));
        return;
    }
    pushdown(o,L,R);
    if(ql <= M) updatea(ls,L,M);
    if(qr > M) updatea(rs,M+1,R);
    sumv[o] = add(sumv[ls], sumv[rs]);
}
inline void updatem(LL o,LL L,LL R) {
    if(ql <= L && R <= qr) {
        mulv[o] = mul(mulv[o],qm);
        addv[o] = mul(addv[o],qm);//加法标记*c
        sumv[o] = mul(sumv[o],qm);
        return;
    }
    pushdown(o,L,R);
    if(ql <= M) updatem(ls,L,M);
    if(qr > M) updatem(rs,M+1,R);
    sumv[o] = add(sumv[ls], sumv[rs]);
}
inline LL query(LL o,LL L,LL R) {
    if(ql <= L && R <= qr) return sumv[o];
    pushdown(o,L,R);
    LL ret = 0;
    if(ql <= M) ret = add(ret, query(ls,L,M));
    if(qr > M) ret = add(ret, query(rs,M+1,R));
    return ret%p;
}
int main() {
    scanf("%lld%lld%lld",&n,&m,&p);
    for(int i = 1;i <= n;i++) scanf("%lld",&A[i]);
    build(1,1,n);
    for(int i = 1,x;i <= m;i++) {
        scanf("%d",&x);
        if(x == 1) {
            scanf("%lld%lld%lld",&ql,&qr,&qm);
            updatem(1,1,n);
        } else if(x == 2) {
            scanf("%lld%lld%lld",&ql,&qr,&qa);
            updatea(1,1,n);
        } else {
            scanf("%lld%lld",&ql,&qr);
            printf("%lld\n", query(1,1,n));
        }
    }
    return 0;
}
```

### 位运算线段树

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e6+10;
const int mod=1e9+7;
const int INF=0x3f3f3f3f;
struct arr{
	int sum[4],lazy[4];
}tr[maxn];
int n,m,a[maxn];
void pushup(int node,int i){
	tr[node].sum[i]=tr[node<<1].sum[i]+tr[node<<1|1].sum[i];
}
void pushdown(int node,int mid,int i){
	if(!tr[node].lazy[i]){//如果进行了AND操作，并且该位为0 清空下面子树。
		tr[node<<1].lazy[i]=0;
		tr[node<<1|1].lazy[i]=0;
		tr[node<<1].sum[i]=tr[node<<1|1].sum[i]=0;
	}
	if(tr[node].lazy[i]==1){ //如果进行了OR 操作，并且该位为1 填满下面子树。
		tr[node<<1].lazy[i]=1;
		tr[node<<1|1].lazy[i]=1;
		tr[node<<1].sum[i]=mid-(mid>>1);
		tr[node<<1|1].sum[i]=mid>>1;
	}
	if(tr[node].lazy[i]==2){   //如果进行了XOR操作
		if(tr[node<<1].lazy[i]==INF){//如果没有进行过任何操作，标记为XOR操作
			tr[node<<1].lazy[i]=2;
			tr[node<<1].sum[i]=mid-(mid>>1)-tr[node<<1].sum[i];
		}else if(tr[node<<1].lazy[i]==2){ //如果进行过XOR操作，a^b^b==a 恢复操作内容。
			tr[node<<1].lazy[i]=INF;
			tr[node<<1].sum[i]=mid-(mid>>1)-tr[node<<1].sum[i];
		}else{
			tr[node<<1].lazy[i]^=1;
			if(!tr[node<<1].lazy[i])tr[node<<1].sum[i]=0;
			else tr[node<<1].sum[i]=mid-(mid>>1);
		}
		//另一颗子树同理
		if(tr[node<<1|1].lazy[i]==INF){
			tr[node<<1|1].lazy[i]=2;
			tr[node<<1|1].sum[i]=(mid>>1)-tr[node<<1|1].sum[i];
		}else if(tr[node<<1|1].lazy[i]==2){
			tr[node<<1|1].lazy[i]=INF;
			tr[node<<1|1].sum[i]=(mid>>1)-tr[node<<1|1].sum[i];
		}else{
			tr[node<<1|1].lazy[i]^=1;
			if(!tr[node<<1|1].lazy[i])tr[node<<1|1].sum[i]=0;
			else tr[node<<1|1].sum[i]=mid>>1;
		}
	}
	tr[node].lazy[i]=INF;
}
void build(int l,int r,int node){
	for(int i=0;i<4;i++)tr[node].lazy[i]=INF;
	if(l==r){
		for(int i=0;i<4;i++)tr[node].sum[i]=(bool)(a[l]&(1<<i));
		return;
	}
	int mid=(l+r)>>1;
	build(l,mid,node<<1);
	build(mid+1,r,node<<1|1);
	for(int i=0;i<4;i++)pushup(node,i);
}
void update(int L,int R,int v,int i,int l,int r,int node){
	if(r<=R &&L<=l){
		if(v==0)tr[node].sum[i]=0,tr[node].lazy[i]=v;
		if(v==1)tr[node].sum[i]=r-l+1,tr[node].lazy[i]=v;
		if(v==2){
			tr[node].sum[i]=r-l+1-tr[node].sum[i];
			if(tr[node].lazy[i]==2)tr[node].lazy[i]=INF;
			else if(tr[node].lazy[i]==INF)tr[node].lazy[i]=2;
			else tr[node].lazy[i]^=1;
		}
		return;
	}
	pushdown(node,r-l+1,i);
	int mid=(r+l)>>1;
	if(L<=mid)update(L,R,v,i,l,mid,node<<1);
	if(R>mid)update(L,R,v,i,mid+1,r,node<<1|1);
	pushup(node,i);
}
int query(int L,int R,int i,int l,int r,int node){
	if(L<=l && r<=R)return tr[node].sum[i];
	int mid=(l+r)>>1,ans=0;
	pushdown(node,r-l+1,i);
	if(L<=mid)ans+=query(L,R,i,l,mid,node<<1);
	if(R>mid)ans+=query(L,R,i,mid+1,r,node<<1|1);
	return ans;
}
ll read(){
    ll f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
int main(){
	int T;
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n;i++)scanf("%d",&a[i]);
		build(1,n,1);
		while(m--){
			char opt[5];
			scanf("%s",&opt);
			if(opt[0]=='S'){
				int l,r,sum=0;
				scanf("%d%d",&l,&r);
				l++,r++;
				for(int i=0;i<4;i++)
					sum+=query(l,r,i,1,n,1)<<i;
				printf("%d\n",sum);
			}else{
				int x,l,r;
				scanf("%d%d%d",&x,&l,&r);
				l++,r++;
				if(opt[0]=='A'){
					for(int i=0;i<4;i++){
						int num=x&(1<<i);
						if(!num)update(l,r,0,i,1,n,1);
					}
				}
				if(opt[0]=='O'){
					for(int i=0;i<4;i++){
						int num=x&(1<<i);
						if(num)update(l,r,1,i,1,n,1);
					}
				}
				if(opt[0]=='X'){
					for(int i=0;i<4;i++){
						int num=x&(1<<i);
						if(num)update(l,r,2,i,1,n,1);
					}
				}
			}
		}
	}
	return 0;
}
```



### 线段树最大子段和

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e4+10;
const int mod=1e9+7;
const ll INF=1e11;
ll read(){
    ll f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
struct arr{
	ll lmx,rmx,sum,num;//lmx前缀 rmx后缀 
}s[maxn*4],nul;
ll a[maxn];
int n;
arr pushup(arr a,arr b){	
	arr t;
	t.sum=a.sum+b.sum;
    t.lmx=max(a.sum+b.lmx,a.lmx);
    t.rmx=max(b.sum+a.rmx,b.rmx);
    t.num=max(a.num,max(b.num,a.rmx+b.lmx));
	return t;
}
void build(int node,int l,int r){
	int mid=(l+r)>>1;
	if(l==r){
		s[node].sum=a[l];
		s[node].lmx=a[l];
		s[node].rmx=a[l];
		s[node].num=a[l];
		return;
	}
	build(node<<1,l,mid);
	build(node<<1|1,mid+1,r);
	s[node]=pushup(s[node<<1],s[node<<1|1]);
}
arr query(int L,int R,int l,int r,int node){
	if(L>R)return nul;
	int mid=(l+r)>>1;
	if(L<=l && r<=R)return s[node];
	if(R<=mid)return query(L,R,l,mid,node<<1);
	if(L>mid)return query(L,R,mid+1,r,node<<1|1);
	return pushup(query(L,R,l,mid,node<<1),query(L,R,mid+1,r,node<<1|1));
}
ll solve(int s1,int e1,int s2,int e2){
	ll ans=0;
	if(e1<s2){
		ans+=query(e1,s2,1,n,1).sum;
		ans+=max(1ll*0,query(s1,e1-1,1,n,1).rmx);
		ans+=max(1ll*0,query(s2+1,e2,1,n,1).lmx);
	}else{
		arr a1=query(s1,s2-1,1,n,1);
		arr a2=query(s2,e1,1,n,1);
		arr a3=query(e1+1,e2,1,n,1);
		ans=max(a2.num,a1.rmx+a2.lmx);
		ans=max(ans,a2.rmx+a3.lmx);
		ans=max(ans,a1.rmx+a2.sum+a3.lmx);
	}
	return ans;
}
int main(){
	int T;
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
		build(1,1,n);
		int q;
		scanf("%d",&q);
		while(q--){
			int st1,ed1,st2,ed2;
			scanf("%d%d%d%d",&st1,&ed1,&st2,&ed2);
			printf("%lld\n",solve(st1,ed1,st2,ed2));
		}
	}
	return 0;
}
/*
	分两种情况
	1：相交
		按照答案的左右区间所在位置分类讨论
		共四种
		1）答案区间在相交部分 区间和 
		2）左不在右在 左最大后缀+右最大前缀 
		3）左在右不在 同2） 
		4）左右都不在 同2 
	2：不交
		左最大后缀+右最大前缀+左右间的区间和 
	 
*/
```

### 区间加等差数列并求和

```cpp
typedef long long LL;
const int MAXN = 200010;
const LL mod = 223092870;
struct Node{
    LL d, first, sum;
}t[MAXN<<2];
LL a[MAXN];
int n, m;
 
inline void pd(int i,int l,int r) {
    if (t[i].d || t[i].first) {
        int mid = (l + r) >> 1;
        (t[i<<1].d += t[i].d) %= mod;
        (t[i<<1|1].d += t[i].d) %= mod;
        (t[i<<1].first += t[i].first) %= mod;
        (t[i<<1|1].first += (t[i].first+(mid-l+1)*t[i].d%mod)) %= mod;
        (t[i<<1].sum += t[i].first*(mid-l+1)%mod+(1ll*(mid-l+1)*(mid-l)/2)%mod*t[i].d%mod) %= mod;
        (t[i<<1|1].sum += (t[i].first+(mid-l+1)*t[i].d)%mod*(r-mid)%mod+(1ll*(r-mid)*(r-mid-1)/2)%mod*t[i].d%mod) %= mod;
        t[i].d = t[i].first = 0;
    }
}
 
void ins(int i, int l, int r, int x, int y, int first, int d) {
    if (x <= l && r <= y){
        (t[i].d += d) %= mod;
        (t[i].first += 1ll*(l-x)*d%mod+first) %= mod;
        (t[i].sum += (1ll*(l-x)*d%mod+first)%mod*(r-l+1)%mod + (1ll*(r-l+1)*(r-l)/2)%mod*d%mod) %= mod;
        return;
    }
    pd(i, l, r);
    int mid = (l + r) >> 1;
    if (x <= mid) ins(i<<1,l,mid,x,y,first,d);
    if (y > mid) ins(i<<1|1,mid+1,r,x,y,first,d);
    t[i].sum = (t[i<<1].sum + t[i<<1|1].sum) % mod;
}
 
LL query(int i,int l,int r,int x, int y) {
    if(x <= l && r <= y) return t[i].sum;
    pd(i,l,r);
    int mid = (l+r) >> 1; LL re = 0;
    if (x <= mid)  re += query(i<<1,l,mid,x,y);
    if (y > mid) re += query(i<<1|1,mid+1,r,x,y);
    return re;
}
 
int main()
{  
    read(n);
    for (int i=1;i<=n;i++) read(a[i]), (a[i] += a[i-1]) %= mod;
    read(m);
    int op, l, r, v, d;
    while(m--) {
        read(op);
        if(op == 1) {
            read(l), read(r), read(v), read(d);
            ins(1, 1, n, l, r, v, d);
        }
        else {
            read(l), read(r), read(v);
            printf("%lld\n", ((query(1,1,n,l,r)+a[r]-a[l-1])%v+v)%v);
        }
    }
}
```



## 主席树

### 静态

```cpp
//求区间第k大 若求第k小改成第ri-le+1-k大
#include<stdio.h>
#include<string.h>
#include<algorithm>
#include<iostream>
using namespace std;
const int maxn=1e5+5;
int root[20*maxn],sum[20*maxn],le[20*maxn],ri[20*maxn];
int a[maxn],b[maxn];
int len,cnt,n,m,T,i,j,x,y,v;
void build(int& node,int l,int r){
    node=++cnt;
    sum[node]=0;
    if(!(l-r))return ;
    int mid=(l+r)>>1;
    build(le[node],l,mid);
    build(ri[node],mid+1,r);
}
void update(int& now,int pre,int l,int r,int p){
    now=++cnt;
    le[now]=le[pre];
    ri[now]=ri[pre];
    sum[now]=sum[pre]+1;
    if(!(l-r))return ;
    int mid=(l+r)>>1;
    if(p>mid)update(ri[now],ri[pre],mid+1,r,p);
    else update(le[now],le[pre],l,mid,p);
}
int query(int pre,int now,int l,int r,int k){
    if(!(l-r))return b[l];
    int mid=(l+r)>>1;
    int c=sum[le[now]]-sum[le[pre]];
    if(k<=c)return query(le[pre],le[now],l,mid,k);
    else return query(ri[pre],ri[now],mid+1,r,k-c);
}
int main(){
    scanf("%d",&T);
    while(T--){
        cnt=0;
        scanf("%d%d",&n,&m);
        for(i=1;i<=n;i++){
            scanf("%d",&a[i]);
            b[i]=a[i];
        }
        sort(b+1,b+1+n);
        len=unique(b+1,b+1+n)-(b+1);
        build(root[0],1,len);
        for(i=1;i<=n;i++)a[i]=lower_bound(b+1,b+1+len,a[i])-b;
        for(i=1;i<=n;i++)update(root[i],root[i-1],1,len,a[i]);
        for(i=1;i<=m;i++){
            scanf("%d%d%d",&x,&y,&v);
            printf("%d\n",query(root[x-1],root[y],1,len,v));//区间[x,y]第v大
        }
    }
    return 0;
}
```

### 动态

```cpp
#include "stdio.h"
#include "string.h"
#include "algorithm"
#include "iostream"
using namespace std;
typedef long long LL;
const int maxn=1e5+10;
int n,m,tot,v,d;
int le,ri,val,x,k;
int root[maxn],ls[20*maxn],rs[20*maxn],c[20*maxn],a[maxn];
int xx[30],yy[30];
char opt[2];
int lowbit(int x){
    return x&(-x);
}
void update(int &now,int le,int ri){
    int mid=(le+ri)/2;
    if(!now)now=++tot;
    c[now]+=d;
    if(le==ri)return;
    if(v<=mid)update(ls[now],le,mid);
    else update(rs[now],mid+1,ri);
}
int query(int le,int ri,int k){
    le--;swap(le,ri);
    int t1=0,t2=0;
    for(int i=le;i>=1;i-=lowbit(i))xx[++t1]=root[i];
    for(int i=ri;i>=1;i-=lowbit(i))yy[++t2]=root[i];
    int l=0,r=1e9;
    while(l<r){
        int temp=0;//calc left son
        for(int i=1;i<=t1;i++)temp+=c[ls[xx[i]]];
        for(int i=1;i<=t2;i++)temp-=c[ls[yy[i]]];
        if(k<=temp){//left son
            for(int i=1;i<=t1;i++)xx[i]=ls[xx[i]];
            for(int i=1;i<=t2;i++)yy[i]=ls[yy[i]];
            r=(l+r)/2;
        }else{//right son
            for(int i=1;i<=t1;i++)xx[i]=rs[xx[i]];
            for(int i=1;i<=t2;i++)yy[i]=rs[yy[i]];
            k-=temp;l=(l+r)/2+1;
        }
    }
    return l;
}
void change(int x,int num){
    d=-1,v=a[x];
    for(int i=x;i<=n;i+=lowbit(i))update(root[i],0,1e9);
    d=1,v=num;
    for(int i=x;i<=n;i+=lowbit(i))update(root[i],0,1e9);
    a[x]=num;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        d=1;v=a[i];
        for(int j=i;j<=n;j+=lowbit(j))update(root[j],0,1e9);
    }
    while(m--){
        scanf("%s",&opt);
        if(opt[0]=='Q'){
            scanf("%d%d%d",&le,&ri,&k);
            printf("%d\n",query(le,ri,k));
        }
        if(opt[0]=='C'){
            scanf("%d%d",&x,&val);
            change(x,val);
        }
    }
    return 0;
}
```

# 数论

## 博弈论

### SG函数

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int sg[1001],a[1001];
void getsg(){    
     bool mex[1001];    
	 for(int i=0;i<=m;i++){        
	     memset(mex,false,sizeof(mex));        		
		 for (int j=1;j<=n;j++){        			
		    if (i-a[j]>=0){
		     	mex[sg[i-a[j]]]=true;
			}
		}        
		for(int j=0;j<=m;j++){
		    if(mex[j]==false){                
			   sg[i]=j;                
			   break;            
			}    
		}
	}
	return;
}//有一堆n个石子 从中只能取走ai个 若sgn=0则必败 
//f[N]:可改变当前状态的方式，N为方式的种类，f[N]要在getSG之前先预处理
//SG[]:0~n的SG函数值
//S[]:为x后继状态的集合
int f[N],SG[MAXN],S[MAXN];
void  getSG(int n){
    int i,j;
    memset(SG,0,sizeof(SG));
    //因为SG[0]始终等于0，所以i从1开始
    for(i = 1; i <= n; i++){
        //每一次都要将上一状态 的 后继集合 重置
        memset(S,0,sizeof(S));
        for(j = 0; f[j] <= i && j <= N; j++)
            S[SG[i-f[j]]] = 1;  //将后继状态的SG函数值进行标记
        for(j = 0;; j++) if(!S[j]){   //查询当前后继状态SG值中最小的非零值
            SG[i] = j;
            break;
        }
    }
}


//注意 S数组要按从小到大排序 SG函数要初始化为-1 对于每个集合只需初始化1遍
//n是集合s的大小 S[i]是定义的特殊取法规则的数组
int s[110],sg[10010],n;
int SG_dfs(int x)
{
    int i;
    if(sg[x]!=-1)
        return sg[x];
    bool vis[110];
    memset(vis,0,sizeof(vis));
    for(i=0;i<n;i++)
    {
        if(x>=s[i])
        {
            SG_dfs(x-s[i]);
            vis[sg[x-s[i]]]=1;
        }
    }
    int e;
    for(i=0;;i++)
        if(!vis[i])
        {
            e=i;
            break;
        }
    return sg[x]=e;
}
```

### 巴什博弈

![image-20201015164945894](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201015164945894.png)

### 尼姆博弈

![image-20201015165041626](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201015165041626.png)

![image-20201015165102828](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201015165102828.png)

### 威佐夫博弈

![image-20201015165153266](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201015165153266.png)

![image-20201015165208673](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201015165208673.png)

![image-20201015165220050](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201015165220050.png)

### 斐波那契博弈

![image-20201015165253818](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201015165253818.png)

## 组合数取模

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL maxn=10000000;
const LL p=1000000007;
LL f[maxn+10];
void init(){//阶乘
    f[0]=1;
    for(LL i=1;i<=maxn;i++){
        f[i]=(long long)f[i-1]*i%p;
    }
}
LL fast(LL a,LL n){
    if(n==0)return 1;
    if(n%2)return (long long)a*fast(a,n-1)%p;
    LL tmp=fast(a,n/2);
    return (long long)tmp*tmp%p;
}
LL C(LL n,LL m){
    if(n==m||m==0)return 1;
    return ((long long)f[n]*fast(f[m],p-2)%p)*fast(f[n-m],p-2)%p;
}
int main(){
    init();
    LL n,m;
    while(~scanf("%lld%lld",&m,&n)){
        printf("%lld ",C(n-1,m-1));
        printf("%lld\n",C(n+m-1,m-1));
    }
    return 0;
}
/*
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const LL maxn=10000000;
const LL p=100019;
LL f[maxn+10];
void init(){//阶乘
    f[0]=1;
    for(LL i=1;i<p;i++){
        f[i]=(long long)f[i-1]*i%p;
    }
}
LL quick(LL a,LL b){
	LL res=1;
	while(b){
		if(b&1)res=res*a%p;
		a=a*a%p;
		b>>=1;
	}
	return res;
}
LL C(LL n,LL m){
    if(n==m||m==0)return 1;
    LL res=1;
    while(n && m){
    	LL a1=n%p,b1=m%p;
    	if(a1<b1)return 0;
    	res=res*f[a1]*quick(f[b1]*f[a1-b1]%p,p-2)%p;
    	n/=p;m/=p;
	}
	return res;
}
int main(){
    init();
    LL n,m=8;
    while(~scanf("%lld",&n)){
    	n+=8;
    	printf("%lld\n",C(n,m));
    }
    return 0;
}
*/
```

## 米勒罗宾素数判断

```cpp
#include "stdio.h"
#include "string.h"
#include "algorithm"
#include "iostream"
#include "math.h"
using namespace std;
typedef long long LL;
LL n,flag,prime[6] = {2, 3, 5, 233, 331};
LL qmul(LL x,LL y,LL mod){// // 乘法防止溢出， 如果p * p不爆LL的话可以直接乘； O(1)乘法或者转化成二进制加法
    return (x * y - (long long)(x / (long double)mod * y + 1e-3) *mod + mod) % mod;
}
LL qpow(LL a,LL n,LL mod){
    LL ret=1;
    while(n){
        if(n&1)ret=qmul(ret,a,mod);
        a=qmul(a,a,mod);
        n>>=1;
    }
    return ret;// 18位素数：154590409516822759 19位素数：2305843009213693951 (梅森素数)19位素数：4384957924686954497

}
bool Miller_Rabin(LL p){
    if(p<2)return 0;
    if(p!=2 && !(p%2))return 0;
    LL s=p-1;
    while(!(s&1))s>>=1;
    for(int i=0;i<5;i++){
        if(p==prime[i])return 1;
        LL t=s,m=qpow(prime[i],s,p);
        while(t!=p-1 && m!=1 && m!=p-1){
            m=qmul(m,m,p);
            t<<=1;
        }
        if(m!=p-1 && !(t&1))return 0;
    }
    return 1;
}
int main(){
	printf("%lld\n",n);
    while(~scanf("%lld",&n)){
        flag=Miller_Rabin(n);
        if(flag)printf("YES\n");
        else printf("NO\n");
    }
    return 0;
}
```

## 判断为第几个素数

```cpp
#include<bits/stdc++.h>
typedef long long LL;
using namespace std;
LL n;
LL doit(LL n){
    LL f[340000],g[340000],i,j,k;
    for(k=1;k*k<=n;k++)f[k]=n/k-1;
    for(i=1;i<=k;i++)g[i]=i-1;
    for(i=2;i<=k;i++){
        if(g[i]==g[i-1])continue;
        for(j=1;j<=min(k-1,n/i/i);j++){
            if(i*j<k)f[j]-=f[i*j]-g[i-1];
            else f[j]-=g[n/i/j]-g[i-1];
        }
        for(j=k;j>=i*i;j--)g[j]-=g[j/i]-g[i-1];
    }
    return f[1];
}
int main(){
    while(~scanf("%lld",&n)){
        printf("%lld\n",doit(n));
    }
    return 0;
}
```

## 矩阵快速幂

```cpp
#include<stdio.h>
#include<string.h>
#include<iostream>
#include<algorithm>
#include<math.h>
using namespace std;
struct arr{
    long long a[3][3];
}ans,shu,mp,bz;
int T;
long long n,a,b,c,p;
long long quick(long long a,long long b){
    long long ans=1;
    while(b){
        if(b&1)ans=ans*a%p;
        a=a*a%p;
        b>>=1;
    }
    return ans;
}
arr matrix(arr x,arr y){
    for(int i=0;i<3;i++)
        for(int j=0;j<3;j++){
            mp.a[i][j]=0;
            for(int k=0;k<3;k++)
                mp.a[i][j]=(mp.a[i][j]+x.a[i][k]*y.a[k][j]%(p-1))%(p-1);
        }
    return mp;
}
long long work(long long k){
    ans={1,0,0,0,1,0,0,0,1};
    while(k){
        if(k&1)ans=matrix(ans,shu);
        k>>=1;
        shu=matrix(shu,shu);
    }
    return (ans.a[0][0]*b%(p-1)+ans.a[0][2]*b%(p-1))%(p-1);//费马小定理
}
int main(){
    scanf("%d",&T);
    while(T--){
        scanf("%lld%lld%lld%lld%lld",&n,&a,&b,&c,&p);
        if(n==1)printf("1\n");
        if(n==2)printf("%lld\n",quick(a,b));
        if(n>=3){
            shu={c,1,1,1,0,0,0,0,1};
            if(!(a%p))printf("0\n");
            else printf("%lld\n",quick(a,work(n-2)));
        }
    }
    return 0;
}
```

## 线性递推

```cpp
#include <cstdio>

#include <cstring>

#include <cmath>

#include <algorithm>

#include <vector>

#include <string>

#include <map>

#include <set>

#include <cassert>

using namespace std;

#define rep(i,a,n) for (int i=a;i<n;i++)

#define per(i,a,n) for (int i=n-1;i>=a;i--)

#define pb push_back

#define mp make_pair

#define all(x) (x).begin(),(x).end()

#define fi first

#define se second

#define SZ(x) ((int)(x).size())

typedef vector<int> VI;

typedef long long ll;

typedef pair<int,int> PII;

const ll mod=1000000007;

ll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}

// head



int _,n;

namespace linear_seq {

    const int N=10010;

    ll res[N],base[N],_c[N],_md[N];



    vector<int> Md;

    void mul(ll *a,ll *b,int k) {

        rep(i,0,k+k) _c[i]=0;

        rep(i,0,k) if (a[i]) rep(j,0,k) _c[i+j]=(_c[i+j]+a[i]*b[j])%mod;

        for (int i=k+k-1;i>=k;i--) if (_c[i])

            rep(j,0,SZ(Md)) _c[i-k+Md[j]]=(_c[i-k+Md[j]]-_c[i]*_md[Md[j]])%mod;

        rep(i,0,k) a[i]=_c[i];

    }

    int solve(ll n,VI a,VI b) { // a ?μêy b 3??μ b[n+1]=a[0]*b[n]+...

//        printf("%d\n",SZ(b));

        ll ans=0,pnt=0;

        int k=SZ(a);

        assert(SZ(a)==SZ(b));

        rep(i,0,k) _md[k-1-i]=-a[i];_md[k]=1;

        Md.clear();

        rep(i,0,k) if (_md[i]!=0) Md.push_back(i);

        rep(i,0,k) res[i]=base[i]=0;

        res[0]=1;

        while ((1ll<<pnt)<=n) pnt++;

        for (int p=pnt;p>=0;p--) {

            mul(res,res,k);

            if ((n>>p)&1) {

                for (int i=k-1;i>=0;i--) res[i+1]=res[i];res[0]=0;

                rep(j,0,SZ(Md)) res[Md[j]]=(res[Md[j]]-res[k]*_md[Md[j]])%mod;

            }

        }

        rep(i,0,k) ans=(ans+res[i]*b[i])%mod;

        if (ans<0) ans+=mod;

        return ans;

    }

    VI BM(VI s) {

        VI C(1,1),B(1,1);

        int L=0,m=1,b=1;

        rep(n,0,SZ(s)) {

            ll d=0;

            rep(i,0,L+1) d=(d+(ll)C[i]*s[n-i])%mod;

            if (d==0) ++m;

            else if (2*L<=n) {

                VI T=C;

                ll c=mod-d*powmod(b,mod-2)%mod;

                while (SZ(C)<SZ(B)+m) C.pb(0);

                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;

                L=n+1-L; B=T; b=d; m=1;

            } else {

                ll c=mod-d*powmod(b,mod-2)%mod;

                while (SZ(C)<SZ(B)+m) C.pb(0);

                rep(i,0,SZ(B)) C[i+m]=(C[i+m]+c*B[i])%mod;

                ++m;

            }

        }

        return C;

    }

    int gao(VI a,ll n) {

        VI c=BM(a);

        c.erase(c.begin());

        rep(i,0,SZ(c)) c[i]=(mod-c[i])%mod;

        return solve(n,c,VI(a.begin(),a.begin()+SZ(c)));

    }

};



int main() {

    for (scanf("%d",&_);_;_--) {

        scanf("%d",&n);
		VI v;
		
		v.push_back(3);
		v.push_back(7);
		v.push_back(16);
        v.push_back(37);
		printf("%d\n",linear_seq::gao(v,n-1));

    }

}
```

## 线性基

```cpp
struct L_B{
    long long d[61],p[61];
    int cnt;
    L_B()
    {
        memset(d,0,sizeof(d));
        memset(p,0,sizeof(p));
        cnt=0;
    }
    bool insert(long long val)
    {
        for (int i=60;i>=0;i--)
            if (val&(1LL<<i))
            {
                if (!d[i])
                {
                    d[i]=val;
                    break;
                }
                val^=d[i];
            }
        return val>0;
    }
    long long query_max()
    {
        long long ret=0;
        for (int i=60;i>=0;i--)
            if ((ret^d[i])>ret)
                ret^=d[i];
        return ret;
    }
    long long query_min()
    {
        for (int i=0;i<=60;i++)
            if (d[i])
                return d[i];
        return 0;
    }
    void rebuild()
    {
        for (int i=60;i>=0;i--)
            for (int j=i-1;j>=0;j--)
                if (d[i]&(1LL<<j))
                    d[i]^=d[j];
        for (int i=0;i<=60;i++)
            if (d[i])
                p[cnt++]=d[i];
    }
    long long kthquery(long long k)
    {
        int ret=0;
        if (k>=(1LL<<cnt))
            return -1;
        for (int i=60;i>=0;i--)
            if (k&(1LL<<i))
                ret^=p[i];
        return ret;
    }
}
L_B merge(const L_B &n1,const L_B &n2)
{
    L_B ret=n1;
    for (int i=60;i>=0;i--)
        if (n2.d[i])
            ret.insert(n1.d[i]);
    return ret;
}
/*
1.设线性基的异或集合中不存在00。 
2.线性基的异或集合中每个元素的异或方案唯一，其实这个跟性质1是等价的。 
3.线性基二进制最高位互不相同。 
4.如果线性基是满的，它的异或集合为[1,2n?1][1,2n?1]。 
5.线性基中元素互相异或，异或集合不变。
*/
```

## 整除分块

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,ans;
int main()
{
    // \sum{i=1,n}n/i;
  scanf("%lld",&n);
  for(int l=1,r;l<=n;l=r+1)
     {
        r=n/(n/l);
        ans+=(r-l+1)*(n/l);
        cout<<l<<' '<<r<<' '<<ans<<endl;
     }
  printf("%lld",ans);
}
```

## 中国剩余定理

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e5+10;
const int mod=1e9+7;
const int INF=0x3f3f3f3f;
ll read(){
    ll f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
ll m[maxn],r[maxn];
int n;
void exgcd(ll a,ll b,ll &d,ll &x,ll &y){
	if(!b)d=a,x=1,y=0;
	else {
		exgcd(b,a%b,d,y,x);
		y-=x*(a/b);
	}
}
ll exchina(int n){
	ll M=m[1],R=r[1],x,y,d;
	for(int i=2;i<=n;i++){
		exgcd(M,m[i],d,x,y);
		if((r[i]-R)%d)return -1;
		x=(r[i]-R)/d*x%(m[i]/d);
		R+=x*M;
		M=M/d*m[i];
		R%=M;
	}
	if(R>0)return R;
	return R+M;
}
int main(){
	while(~scanf("%d",&n)){
		for(int i=1;i<=n;i++)scanf("%lld%lld",&m[i],&r[i]);
		printf("%lld\n",exchina(n));
	}
	return 0;
}
/*
中国剩余定理解同余方程组
typedef __int128 ll;
inline ll exgcd(ll p,ll q,ll &x,ll &y){
    if(!q){
        x=1;
        y=0;
        return p;
    }
    ll g=exgcd(q,p%q,y,x);
    y-=(p/q)*x;
    return g;
}
ll excrt(){
    M=b[1];
    ans=a[1];
    for(ll i=2;i<=n;++i){
        ll c=((a[i]-ans)%b[i]+b[i])%b[i];
        ll g=exgcd(M,b[i],x,y);
        ll p=b[i]/g;        
		if(c%g!=0)return -1;//判断无解
        if(M>ll(1e15))continue;
        x=mul(x,c/g,p);//快速乘 
        ans+=x*M;
        M*=p;
        ans=(ans%M+M)%M;
    }
    return ans;
}
*/
```

## 高斯消元

```cpp
#include <algorithm>
#include <cstring>
#include <cmath>
#define nmax 100
using namespace std;
int a[nmax][nmax];
int x[nmax];
int free_x[nmax];
int gcd(int a,int b){
    if(!b) return a; else return gcd(b,a%b);
}
int lcm(int a,int b){
    return a/gcd(a,b)*b;
}
int Gauss(int equ,int var){
    int k,max_r,col = 0,ta,tb;
    int LCM,temp,num = 0,free_index;
    for(int i=0;i<=var;i++){
        x[i]=0;
        free_x[i]=true;
    }
    for(k = 0;k < equ && col < var;k++,col++){
        max_r=k;
        for(int i=k+1;i<equ;i++){
            if(abs(a[i][col])>abs(a[max_r][col])) max_r=i;
        }
        if(max_r!=k){// 与第k行交换.
            for(int j=k;j<var+1;j++) swap(a[k][j],a[max_r][j]);
        }
        if(a[k][col]==0){// 说明该col列第k行以下全是0了，则处理当前行的下一列.
            free_x[num++] = col;
            k--;
            continue;
        }
        for(int i=k+1;i<equ;i++){// 枚举要删去的行.
            if(a[i][col]!=0){
                LCM = lcm(abs(a[i][col]),abs(a[k][col]));
                ta = LCM/abs(a[i][col]);
                tb = LCM/abs(a[k][col]);
                if(a[i][col]*a[k][col]<0)tb=-tb;//异号的情况是相加
                for(int j=col;j<var+1;j++){
                    a[i][j] = a[i][j]*ta-a[k][j]*tb;
                }
            }
        }
    }
    //无解
    for (int i = k; i < equ; i++){
        if (a[i][col] != 0) return -1;
    }
    //无穷解
    if (k < var){
        return var - k; // 自由变元有var - k个.
    }
    //唯一解
    for (int i = var - 1; i >= 0; i--){
        temp = a[i][var];
        for (int j = i + 1; j < var; j++){
            if (a[i][j] != 0) temp -= a[i][j] * x[j];
        }
        if (temp % a[i][i] != 0) return -2; // 说明有浮点数解，但无整数解.
        x[i] = temp / a[i][i];
    }
    return 0;
}//整数方程组

#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
using namespace std;
const int N = 1010;
const double EPS=1e-7;
int m,n;
double a[N][N],x[N];
int Gauss(int m,int n){
    int col=0, k=0;//col为列号,k为行号
    for (;k<m&&col<n;++k,++col){
        int r = k;
        for (int i=k+1;i<m;++i)
            if(fabs(a[i][col])>fabs(a[r][col]))r=i;
        if (fabs(a[r][col])<EPS){k--;continue;}//列全为0
        if (r!=k)for(int i=col;i<=n;++i)
            swap(a[k][i],a[r][i]);
        for (int i=k+1;i<m;++i)//消元
            if(fabs(a[i][col])>EPS){
            double t = a[i][col]/a[k][col];
            for (int j=col;j<=n;j++)a[i][j]-=a[k][j]*t;
            a[i][col] = 0;
        }
    }
    for(int i=k ;i<m ;++i)//无解
        if (fabs(a[i][n])>EPS) return -1;
    if (k < n) return n - k;  //自由元个数
    for (int i =n-1; i>=0; i--){//回带求解
        double temp = a[i][n];
        for (int j=i+1; j<n; ++j)
            temp -= x[j] * a[i][j];
        x[i] = (temp / a[i][i]);
    }
    return 0;
}//浮点数方程组

#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#define nmax 35
using namespace std;
int a[nmax][nmax];
int x[nmax];
int hashback[nmax][nmax];
int free_x[nmax];
char mp[nmax][nmax];
int ans1,ans2;
int equ,var;
int Gauss(){
    int max_r;
    int col=0,num = 0;
    int k;
    for(int i = 0;i<=var;++i) x[i] = free_x[i] = 0;
    for(k = 0;k < equ && col < var;k++,col++){
        max_r=k;
        for(int i=k+1;i<equ;i++){
            if(abs(a[i][col])>abs(a[max_r][col])) max_r=i;
        }
        if(max_r!=k){
            for(int j=k ;j<var+1;j++) swap(a[k][j],a[max_r][j]);
        }
        if(a[k][col]==0){
            free_x[num++] = col;
            k--; continue;
        }
        for(int i=k+1;i<equ;i++){
            if(a[i][col]!=0){
                for(int j=col;j<var+1;j++){
                    a[i][j]^=a[k][j];;
                }
            }
        }
    }
    for(int i = k;i<equ;++i){
        if(a[i][col] != 0) return -1;
    }
    if(k < var) return var - k;
    for(int i = var - 1; i >= 0; i--){
        x[i]=a[i][var];
        for(int j = i + 1; j < var; j++){
            x[i] ^= ( a[i][j] && x[j]);
        }
    }
    return 0;
}
void enum_freex(int n,int & ans){
    int num = (1<<(n));
    ans = 1e9+7;
    for(int i = 0;i<num;++i){
        int cnt = 0;
        for(int j = 0;j<n;++j){
            if(i&(1<<j)){
                cnt++;
                x[free_x[j]] = 1;
            }else x[free_x[j]] = 0;
        }
        for(int k = var-n-1;k>=0;--k){// 没有自由元的最下面一行
            int index = 0;
            for(index = k;k<var;index++){// 在当前行找到第一个非0自由元(如果存在的话)
                if(a[k][index]) break;
            }
            x[index] = a[k][var];
            for(int j = index+1;j<var;++j){// 向后依次计算出结果
                if(a[k][j]) x[index] ^= x[j];
            }
            cnt += x[index]; // 如果结果为1，则统计
        }
        ans = min(ans,cnt);
    }
}//异或方程组 
```

## 质因数分解

```cpp
#include<bits/stdc++.h>

using namespace std;
typedef long long ll;
map<ll, int>m;
const int mod = 10000019;
const int times = 50;//测试50次
ll mul(ll a, ll b, ll m){//求a*b%m
    ll ans = 0;
    a %= m;
    while(b){
        if(b & 1)ans = (ans + a) % m;
        b /= 2;
        a = (a + a) % m;
    }
    return ans;
}
ll pow(ll a, ll b, ll m){//a^b % m
    ll ans = 1;
    a %= m;
    while(b){
        if(b & 1)ans = mul(a, ans, m);
        b /= 2;
        a = mul(a, a, m);
    }
    ans %= m;
    return ans;
}
bool Miller_Rabin(ll n, int repeat){//n是测试的大数，repeat是测试重复次数
    if(n == 2 || n == 3)return true;//特判
    if(n % 2 == 0 || n == 1)return false;//偶数和1
    //将n-1分解成2^s*d
    ll d = n - 1;
    int s = 0;
    while(!(d & 1)) ++s, d >>= 1;
    //srand((unsigned)time(NULL));在最开始调用即可
    for(int i = 0; i < repeat; i++){//重复repeat次
        ll a = rand() % (n - 3) + 2;//取一个随机数,[2,n-1)
        ll x = pow(a, d, n);
        ll y = 0;
        for(int j = 0; j < s; j++){
            y = mul(x, x, n);
            if(y == 1 && x != 1 && x != (n - 1))return false;
            x = y;
        }
        if(y != 1)return false;//费马小定理
    }
    return true;
}
ll gcd(ll a, ll b){
    return b == 0 ? a : gcd(b, a % b);
}
ll pollard_rho(ll n, ll c){//找到n的一个因子
    ll x = rand() % (n - 2) + 1;
    ll y = x, i = 1, k = 2;
    while(1){
        i++;
        x = (mul(x, x, n) + c) + n;//不断调整x2
        ll d = gcd(y - x, n);
        if(1 < d && d < n)
            return d;//找到因子
        if(y == x)
            return n;//找到循环，返回n，重新来
        if(i == k)//一个优化
        {
            y = x;
            k <<= 1;
        }
    }
}
void Find(ll n, ll c){
    if(n == 1)return;//递归出口
    if(Miller_Rabin(n, times)){//如果是素数，就加入
        m[n]++;
        return;
    }

    ll p = n;
    while(p >= n)
        p = pollard_rho(p, c--);//不断找因子，知道找到为止，返回n说明没找到
    Find(p, c);
    Find(n / p, c);
}
int main(){
    ll n;srand((unsigned)time(NULL));
    while(cin >> n){
        m.clear();
        Find(n, rand() % (n - 1) + 1);//这是自己设置的一个数
        cout<<n<<" = ";
        for(map<ll ,int>::iterator it = m.begin(); it != m.end();){
            cout<<it->first<<" ^ "<<it->second;
            if((++it) != m.end())
               cout<<" * ";
        }
        cout<<endl;
    }
    return 0;
}
```

## 欧拉降幂

```cpp
/*
* @ author: micro_han
* @ email: yxh.op@qq.com
* @ data: 2020-10-12 14:50
*/

/*
欧拉函数
a ^ b = a ^ ( b % phi(p))           gcd(a,p) = 1
a ^ b = a ^ b % p                   gcd(a,p) != 1  &&  b < phi(p)
a ^ b = a ^ (b % phi(p) + phi(p))   gcd(a,p) != 1 && b>=phi(p)

*/


ll phi(ll n)   //单个欧拉函数值 
{  
    int ans=n,temp=n;  
    for(int i=2;i*i<=temp;i++)   
    {  
        if(temp%i==0)   
        {  
            ans-=ans/i;  
            while(temp%i== 0) temp/=i;  
        }  
    }  
    if(temp>1) ans-=ans/temp;  
    return ans;  
}  


int euler()	//n log n  
{
	for(int i=1;i<=1000000;i++)
	{
		phi[i]=i;
	}
	for(int i=2;i<=1000000;i++)
	{
		if(i==phi[i]) //判断如果i是素数 
		{
			for(int j=i;j<=1000000;j+=i)
			{
			    phi[j]=(phi[j]/i)*(i-1);//i是素数并且是j的一个因子，正好满足欧拉函数。 
			}
		}
	}
}
/*
欧拉降幂//a^a^a^a^…^a降幂
ll tmp=a,ans=0;
	if(m==1)return 0;
	if(m==2)return a%2;
	else {
		if(b==0)return 1;
		if(b==1)return a%m;
		//printf("%lld\n",tmp);
		for(int i=1;i<b-1;i++){
			ans=tmp;
			for(int j=1;j<a;j++){
				tmp=tmp*ans;
				//printf("%lld\n",tmp);
				if(tmp<f[m])continue;
				return quick(a,q(a,b-1,f[m])+f[m],m);
			}
		}
		return quick(a,tmp,m);
	}
*/
```

## 拉格朗日插值

```cpp
//O(n*n)
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;
const int M=2111;
const ll mod=998244353;
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline ll read(){
    ll x=0,f=1; char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} int n; ll k,K,ans,x[M],y[M];
inline void AMOD(ll& a,ll& b){ a+=b; if(a>=mod) a%=mod; }
inline ll quick_pow(ll x,ll p,ll ans=1){
    while(p){
        if(p&1) ans=ans*x%mod;
        x=x*x%mod,p>>=1;
    } return ans;
}
int main(){
    n=read(),K=read();
    for(int i=1;i<=n;++i) x[i]=read(),y[i]=read();
    for(int i=1,j;i<=n;++i){ k=1;
        for(j=1;j<=n;++j) if(i!=j)
            k=k*(x[i]+mod-x[j])%mod;
        k=quick_pow(k,mod-2);
        for(j=1;j<=n;++j) if(i!=j)
            k=k*(K+mod-x[j])%mod;
        k=k*y[i]%mod,AMOD(ans,k);
    } return printf("%lld\n",ans),0;
}
/*
O(n)
#include<iostream>
#include<cstdio>
#define ll long long
using namespace std;
const int M=2111;
const ll mod=998244353;
#ifndef Judge
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
#endif
char buf[1<<21],*p1=buf,*p2=buf;
inline ll read(){
    ll x=0,f=1; char c=getchar();
    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
    for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;
} ll n,K,ans,x[M],y[M],s1[M],s2[M],ifac[M];
inline void ADD(ll& a,ll b){ a+=b; if(a>=mod) a%=mod; }
int main(){ n=read()-1,K=read(),s2[n+1]=ifac[0]=ifac[1]=1;
    for(int i=0;i<=n;++i) x[i]=read(),y[i]=read(); s1[0]=(K-x[i])%mod;
    for(int i=1;i<=n;++i) s1[i]=s1[i-1]*(K-x[i])%mod;
    for(int i=n;i>=1;--i) s2[i]=s2[i+1]*(K-x[i])%mod;
    for(int i=2;i<=n;++i) ifac[i]=(mod-mod/i)*ifac[mod%i]%mod;
    for(int i=2;i<=n;++i) ifac[i]=ifac[i]*ifac[i-1]%mod;
    for(int i=0;i<=n;++i)
        ADD(ans,1ll*y[i]*(i?s1[i-1]:1)%mod*s2[i+1]%mod*
            ifac[i]%mod*((n-i&1)?-1:1)*ifac[n-i]%mod);
    return !printf("%lld\n",(ans+mod)%mod);
}
*/
```

# 图论

## 稳定婚姻问题

```cpp
/*稳定婚姻匹配
思路：每个男生向亲密度第一的女生求婚 每个女生选择追求自己的男生中自己最喜欢的 由此可得出对于男生最有利的顺序*/
#include<bits/stdc++.h>
#define N 30
using namespace std;
int xname[N],yname[N];
int xlike[N][N],ylike[N][N],xrank[N][N],yrank[N][N];
int xmat[N],ymat[N];
int i,j,n;
char s,s1[N];
bool find(int x,int y){
    if(ymat[y]==-1){
        xmat[x]=y;
        ymat[y]=x;
        return 1;
    }
    int tx=ymat[y];
    if(yrank[y][tx]>yrank[y][x]){
        xmat[x]=y;ymat[y]=x;
        int ty=xlike[tx][xrank[tx][y]+1];
        if(!find(tx,ty))return 0;
        return 1;
    }else{
        for(int i=xrank[x][y]+1;i<n;i++){
            int ty=xlike[x][i];
            if(!find(x,ty))continue;
            return 1;
        }
        return 0;
    }
}
bool stable_match(){
    memset(xmat,-1,sizeof(xmat));
    memset(ymat,-1,sizeof(ymat));
    for(int i=0;i<n;i++)if(!find(i,xlike[i][0]))return 0;
    return 1;
}
int main(){
    int T;
    scanf("%d",&T);
    while(T--){
        scanf("%d",&n);
        for(i=1;i<=n;i++)scanf("%s",&s),xname[i]=s-'a';
        for(i=1;i<=n;i++)scanf("%s",&s),yname[i]=s-'A';
        for(i=1;i<=n;i++){
            scanf("%s",&s1);
            for(j=2;j<strlen(s1);j++)xlike[s1[0]-'a'][j-2]=s1[j]-'A';
        }
        for(i=1;i<=n;i++){
            scanf("%s",&s1);
            for(j=2;j<strlen(s1);j++)ylike[s1[0]-'A'][j-2]=s1[j]-'a';
        }
        for(i=0;i<n;i++)
            for(j=0;j<n;j++){
                xrank[i][xlike[i][j]]=j;
                yrank[i][ylike[i][j]]=j;
            }
        if(stable_match()){
            for(i=0;i<n;i++)printf("%c %c\n",i+'a',xmat[i]+'A');
        }
        if(T)printf("\n");
    }
    return 0;
}

```

## 二分图匹配

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e5+10;
const int mod=1e9+7;
const int INF=0x3f3f3f3f;
ll read(){
    ll f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
int n,m,k;
int link[220],vis[220],f[220][220];
int dfs(int x){
	for(int i=1;i<=n;i++){
		if(f[x][i] && !vis[i]){
			vis[i]=1;
			if(!link[i] || dfs(link[i])){
				link[i]=x;
				return 1;
			}
		}
	}
	return 0;
}
int find(){
	memset(link,0,sizeof(link));
	int cnt=0;
	for(int i=1;i<=n;i++){
		memset(vis,0,sizeof(vis));
		if(dfs(i))cnt++;
	}
	return cnt;
}
int main(){
	while(~scanf("%d",&n)){
		if(!n)break;
		scanf("%d%d",&m,&k);
		memset(f,0,sizeof(f));
		for(int i=1;i<=k;i++){
			int x,y,z;
			scanf("%d%d%d",&x,&y,&z);
			if(y && z){
				f[y][z]=1;
			}
		}
		printf("%d\n",find());
	} 
	return 0;
}
/*
二分图中最小顶点覆盖等于最大匹配数
二分图中最小边覆盖=顶点数-最小顶点覆盖（最大匹配）
二分图中最大独立集+最小顶点覆盖（最大匹配）=顶点数
*/
```

## 拓扑排序

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=3e4+10;
const int mod=1e9+7;
const int INF=0x3f3f3f3f;
inline int read(){
    int f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
int n,m,cnt,num,ans;
bitset<maxn>f[maxn];
struct arr{
	int next,to;
}edge[50010];
int head[maxn],in[maxn],a[maxn],b[maxn],to[maxn];
inline bool cmp(int x,int y){
	return b[x]<b[y];
}
inline void add(int x,int y){
	cnt++;
	edge[cnt].to=y;edge[cnt].next=head[x];
	head[x]=cnt;
}//存图 
inline void topusort(){
	queue<int>q;
	for(int i=1;i<=n;i++)
		if(!in[i])q.push(i);
	while(!q.empty()){
		int x=q.front();q.pop();
		a[++num]=x;//第几个入队的是谁 
		b[x]=num;//谁第几个入队 
		for(int i=head[x];i!=-1;i=edge[i].next){
			in[edge[i].to]--;
			if(!in[edge[i].to])q.push(edge[i].to);
		}
	}
}
int main(){
	int T;
	scanf("%d",&T);
	while(T--){
		memset(head,-1,sizeof(head));
		cnt=0;num=0;ans=0;
		n=read();m=read();
		for(int i=1;i<=n;i++)f[i].reset();
		for(int i=1;i<=m;i++){
			int x,y;
			x=read();y=read();
			add(x,y);
			in[y]++;
		}
		topusort();
		printf("%d\n",ans);
	}
	return 0;
}
```

## 最小生成树

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=500*250+10;
const int mod=1e9+7;
const int INF=0x3f3f3f3f;
ll read(){
    ll f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
struct arr{
	int x,y,c;
}a[maxn];
int f[maxn],rk[maxn];
int n,m;
bool cmp(arr a,arr b){
	if(a.c==b.c)return a.x<b.x;
	return a.c<b.c;
}
int find(int x){
	if(x!=f[x])return f[x]=find(f[x]);
	return f[x];
}
void unite(int x,int y){
    int a=find(x),b=find(y);
    if(a!=b)f[b]=a;
}
int k(int n,int m){
	int ans=0,tot=0;
    for(int i=1;i<=n;i++){
    	int fa=find(a[i].x),fb=find(a[i].y);
	   	if(fa!=fb){
	        unite(a[i].x,a[i].y);
	        ans+=a[i].c;
	        tot++;
	    }
	    if(tot==m-1)break;
    }
    return ans;
}
int main(){
	int T;
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&n,&m);
		for(int i=1;i<=m;i++)scanf("%d%d%d",&a[i].x,&a[i].y,&a[i].c);
		sort(a+1,a+1+m,cmp);
		for(int i=0;i<n;i++)f[i]=i,rk[i]=0;
		printf("%d\n",k(m,n));
	} 
	return 0;
}
```

## dijsktra

```cpp
#include "stdio.h"
#include "string.h"
#include "algorithm"
#include "iostream"
#include "queue"
using namespace std;
const int maxn=1e5+10;
const int INF=0xfffffff;
struct Edge{
    int to,next,w;
}l[maxn];
struct Node{
    int no,dis;
    friend bool operator < (Node x,Node y){
        return x.dis>y.dis;
    }
}a[maxn];
int n,m,s,x,y,z;
int head[maxn],cnt,cur,dis[maxn];
bool vis[maxn];
priority_queue<Node> q;
void add(int x,int y,int z){
    cnt++;
    l[cnt].to=y,l[cnt].w=z,l[cnt].next=head[x];
    head[x]=cnt;
}
int main(){
    scanf("%d%d%d",&n,&m,&s);
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);
        add(y,x,z);
    }
    for(int i=1;i<=n;i++)a[i].dis=INF,a[i].no=i;
    a[s].dis=0;cur=s;
    q.push(a[s]);
    while(!q.empty()){
        cur=q.top().no;
        q.pop();
        if(vis[cur])continue;
        vis[cur]=1;
        for(int i=head[cur];i;i=l[i].next){
            if(a[l[i].to].dis>a[cur].dis+l[i].w){
                a[l[i].to].dis=a[cur].dis+l[i].w;
                q.push(a[l[i].to]);
            }
        }
    }
    for(int i=1;i<=n;i++)printf("%d:%d\n",i,a[i].dis);
    return 0;
}
```

## tarjan

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e5+10;
const int mod=1e9+7;
const int INF=0x3f3f3f3f;
const int N=3e5+10;
const int Maxn=5e5+10;
const double eps=1e-6;
const ll inf=1e18;
ll read(){
    ll f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
int n,m,low[N],dfn[N];
bool is_cut[N];
int father[N];
int anss;
int tim=0;
vector<int>G[N];
void Tarjan(int i,int Father){
    father[i]=Father;/*记录每一个点的父亲*/
    dfn[i]=low[i]=tim++;
    for(int j=0;j<G[i].size();++j){
        int k=G[i][j];
        if(dfn[k]==-1){
            Tarjan(k,i);
            low[i]=min(low[i],low[k]);
        }
        else if(Father!=k)/*假如k是i的父亲的话，那么这就是无向边中的重边，有重边那么一定不是桥*/
            low[i]=min(low[i],dfn[k]);//dfn[k]可能！=low[k]，所以不能用low[k]代替dfn[k],否则会上翻过头了。
    }
}
void count(){
    int rootson=0;
    Tarjan(1,0);
    for(int i=2;i<=n;++i){
        int v=father[i];
        if(v==1)
        rootson++;/*统计根节点子树的个数，根节点的子树个数>=2,就是割点*/
        else{
            if(low[i]>=dfn[v])/*割点的条件*/
            is_cut[v]=true;
        }
    }
    if(rootson>1)is_cut[1]=true;
  /*  for(int i=1;i<=n;++i)
    	if(is_cut[i])printf("%d\n",i);*/
	anss=0;
    for(int i=1;i<=n;++i){
        int v=father[i];
        if(v>0&&low[i]>dfn[v]) anss++;/*桥的条件*/
      //  printf("%d,%d\n",v,i);
    }
    printf("%d\n",m-anss);
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		G[x].push_back(y);
		G[y].push_back(x);
	}
    memset(dfn,-1,sizeof(dfn));
    memset(father,0,sizeof(father));
    memset(low,-1,sizeof(low));
    memset(is_cut,false,sizeof(is_cut));
    count();
	return 0;
}
/*
tarjan求一个有向图的所有强连通分量
#include "stdio.h"
#include "string.h"
#include "algorithm"
#include "iostream"
#include "math.h"
#include "stack"
using namespace std;
typedef long long LL;
const int maxn=1e5+10;
int n,m,x,y,cnt,tot,num;
int dfn[maxn],head[maxn],low[maxn],vis[maxn],q[maxn];
struct node{
    int v,next;
}edge[maxn];
void add(int x,int y){
    edge[++cnt].v=y;
    edge[cnt].next=head[x];
    head[x]=cnt;
}
void tarjan(int x){//递归点
    dfn[x]=++tot;low[x]=tot;vis[x]=1;
    q[++num]=x;//初始化 模拟栈
    for(int i=head[x];i!=-1;i=edge[i].next){
        if(!dfn[edge[i].v]){//没访问过
            tarjan(edge[i].v);
            low[x]=min(low[x],low[edge[i].v]);//比较谁是父亲/儿子
        }else if(vis[edge[i].v]) low[x]=min(low[x],dfn[edge[i].v]);//比较谁是父亲/儿子
    }
    if(low[x]==dfn[x]){//强连通分量中的最小根
        do{
            printf("%d ",q[num]);
            vis[q[num]]=0;
            num--;
        }while(x!=q[num+1]);//出栈
        printf("\n");
    }
}
int main(){
    memset(head,-1, sizeof(head));
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        scanf("%d%d",&x,&y);
        add(x,y);
    }
    for(int i=1;i<=n;i++)
        if(!dfn[i])tarjan(i);//防止图没走完
    return 0;
}
*/
```

## 2-sat

### 按字典序输出

```cpp
#include "stdio.h"
#include "string.h"
#include "iostream"
#include "algorithm"
#include "stack"
#include "vector"
using namespace std;
const int MAXN = 20020;
const int MAXM = 100010;
struct Edge {
    int to, next;
} edge[MAXM];
int head[MAXN], cntE;
int n,m,u,v;
void init() {
    cntE = 0;
    memset(head, -1, sizeof head);
}
void addedge(int u, int v) {
    edge[cntE].to = v;
    edge[cntE].next = head[u];
    head[u] =cntE++;
}
bool vis[MAXN];
int stk[MAXN], top;
bool dfs(int u) {
    if (vis[u^1]) return false;
    if (vis[u]) return true;
    vis[u] = true; stk[top++] = u;
    for (int i = head[u]; ~i; i = edge[i].next) {
        if (!dfs(edge[i].to)) return false;
    }
    return true;
}
bool sat(int n) {
    memset(vis, false, sizeof vis);
    for (int i = 0; i < n; ++i) {
        if (vis[i] || vis[i ^ 1]) continue;
        top = 0;
        if (!dfs(i)) {
            while (top) vis[stk[--top]] = false;
            if (!dfs(i^1)) return false;
        }
    }
    return true;
}
int main() {
    while (~scanf("%d%d", &n, &m)) {
        init();
        while (m--) {
            scanf("%d%d", &u, &v);
            u--, v--;
            addedge(u, v^1); //选u就必须选择v^1
            addedge(v, u^1);
        }
        n *= 2;
        if (sat(n)) {
            for (int i = 0; i < n; ++i) {
                if (vis[i]) printf("%d\n", i+1);
            }
        } else {
            printf("NIE\n");
        }
    }
    return 0;
}
```

### 输出任意一组解

```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#include <vector>
#include <stack>
#include <algorithm>
#define MAXN
#define MAXM //根据题目需求
#define eps 1e-5
using namespace std;
struct Edge
{
    int from, to, next;
}edge[MAXM];//原图
int head[MAXN], edgenum;
vector<int> G[MAXN];//缩点后新图
int in[MAXN];//新图SCC的入度
int low[MAXN], dfn[MAXN];//通过子女节点所能到达的最低深度优先数  深度优先数
int dfs_clock;//时间戳
int sccno[MAXN], scc_cnt;//sccno[i]表示i属于哪个SCC  scc_cnt是SCC计数器
stack<int> S;//存储当前SCC的点
bool Instack[MAXN];//判断点是否在栈里面
int color[MAXN];//染色
int fp[MAXN];//建立对应SCC编号的映射
void init()
{
    edgenum = 0;
    memset(head, -1, sizeof(head));
}
void addEdge(int u, int v)
{
    Edge E = {u, v, head[u]};
    edge[edgenum] = E;
    head[u] = edgenum++;
}
void getMap()//建图
{
    
}
void tarjan(int u, int fa)//求SCC
{
    int v;
    low[u] = dfn[u] = ++dfs_clock;
    S.push(u);
    Instack[u] = true;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        v = edge[i].to;
        if(!dfn[v])
        {
            tarjan(v, u);
            low[u] = min(low[u], low[v]);
        }
        else if(Instack[v])
            low[u] = min(low[u], dfn[v]);
    }
    if(low[u] == dfn[u])
    {
        scc_cnt++;
        for(;;)
        {
            v = S.top(); S.pop();
            Instack[v] = false;
            sccno[v] = scc_cnt;
            if(v == u) break;
        }
    }
}
void find_cut(int l, int r)
{
    memset(low, 0, sizeof(low));
    memset(dfn, 0, sizeof(dfn));
    memset(sccno, 0, sizeof(sccno));
    memset(Instack, false, sizeof(Instack));
    dfs_clock = scc_cnt = 0;
    for(int i = l; i <= r; i++)
        if(!dfn[i]) tarjan(i, -1);
}
void suodian()//缩点 + 反向建图
{
    for(int i = 1; i <= scc_cnt; i++) G[i].clear(), in[i] = 0;
    for(int i = 0; i < edgenum; i++)
    {
        int u = sccno[edge[i].from];
        int v = sccno[edge[i].to];
        if(u != v)
            G[v].push_back(u), in[u]++; //反向建图
    }
}
void toposort()//拓扑排序 + 染色
{
    queue<int> Q;
    memset(color, 0, sizeof(color));
    for(int i = 1; i <= scc_cnt; i++) if(in[i] == 0) Q.push(i);
    while(!Q.empty())
    {
        int u = Q.front();
        Q.pop();
        if(color[u] == 0)//没有颜色
        {
            color[u] = 1;//染色
            color[fp[u]] = 2;
        }
        for(int i = 0; i < G[u].size(); i++)
        {
            int v = G[u][i];
            if(--in[v] == 0)//入度减一
                Q.push(v);
        }
    }
}
void solve()
{
    memset(fp, 0, sizeof(fp));
    for(int i = 0; i < N; i++)
    {
        if(sccno[2*i] == sccno[2*i + 1])
        {
            printf("无可行解\n");
            return ;
        }
        else
        {
            fp[sccno[2*i]] = sccno[2*i + 1];
            fp[sccno[2*i + 1]] = sccno[2*i];
        }
    }
    suodian();//缩点
    toposort();//拓扑排序 + 染色
    printf("一组可行解:\n");
    for(int i = 1; i < N; i++)
    {
        if(color[sccno[2*i]] == 1)//可行解
            printf("");
    }
    printf("\n");
}
int main()
{
    while("题目输入")
    {
        init();//初始化
        getMap();//建图
        find_cut(1, 2*N-1);//找SCC
        solve();//判断是否存在可行解 或者 输出一组可行解
    }
    return 0;
}
```

## 网络流

### EK

```cpp
//反向找增广路//多源多汇问题建立一个超级源点和超级汇点超级源点可以到原图中所有的点 原图中所有的点可以到超级汇点
#include "stdio.h"
#include "string.h"
#include "iostream"
#include "algorithm"
#include "math.h"
#include "queue"
using namespace std;
typedef long long LL;
const int maxn=1e6+10;
const int INF=0x3f3f3f;
int cnt,head[maxn],dis[maxn],last[maxn],flow[maxn],vis[maxn],maxans;
int n,m,S,T,x,y,z;
struct arr{
    int from,to,next,cost;
}edge[maxn];
queue<int>q;
void add(int x,int y,int z){
    ++cnt;
    edge[cnt].cost=z;edge[cnt].from=x;edge[cnt].to=y;edge[cnt].next=head[x];head[x]=cnt;
}
bool bfs(int S,int T){
    for(int i=1;i<=n;i++)last[i]=0,vis[i]=-1;
    q.push(S);dis[S]=0,vis[S]=1,flow[S]=INF;
    while(!q.empty()){
        int u=q.front();q.pop();vis[u]=0;
        for(int i=head[u];i!=-1;i=edge[i].next){
            int v=edge[i].to;
            if(edge[i].cost && vis[v]==-1){
                flow[v]=min(flow[u],edge[i].cost);
                last[v]=i;
                q.push(v);
                vis[v]=u;
            }
        }
    }
    if(vis[T]!=-1)return true;
    return false;
}
void update(int S,int T){
    int now=T;
    while(now!=S){
        int i=last[now];
        edge[i].cost-=flow[T];edge[i^1].cost+=flow[T];//反向边加
        now=edge[i].from;
    }
    maxans+=flow[T];
}
void EK(){
    maxans=0;
    while(bfs(S,T))update(S,T);
}
int main(){
    cnt=1;memset(head,-1,sizeof(head));
    scanf("%d%d%d%d",&n,&m,&S,&T);
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);
        add(y,x,0);//反向建边
    }
    EK();//n*m^2
    printf("%d\n",maxans);
    return 0;
}
```

### dinic

```cpp
#include "stdio.h"
#include "string.h"
#include "iostream"
#include "algorithm"
#include "math.h"
#include "queue"
using namespace std;
typedef long long LL;
const int maxn=1e6+10;
const int INF=0x3f3f3f;
int n,m,S,T,x,y,z,cnt;
int head[maxn],Rank[maxn];
queue<int>q;
struct arr{
    int from,to,cost,next;
}edge[maxn];
void add(int x,int y,int z){
    cnt++;
    edge[cnt].from=x;edge[cnt].to=y;edge[cnt].cost=z;edge[cnt].next=head[x];head[x]=cnt;
}
bool bfs(){
    memset(Rank,-1,sizeof(Rank));
    Rank[S]=0;q.push(S);
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=head[u];i!=-1;i=edge[i].next){
            int v=edge[i].to;
            if(edge[i].cost && Rank[v]==-1){
                Rank[v]=Rank[u]+1;
                q.push(v);
            }
        }
    }
    if(Rank[T]!=-1)return true;
    return false;
}
int dfs(int u,int flow){
    if(u==T)return flow;
    int ret=flow;
    for(int i=head[u];i!=-1;i=edge[i].next){
        if(ret<=0)break;
        int v=edge[i].to;
        if(edge[i].cost && Rank[u]+1==Rank[v]){
            int k=dfs(v,min(edge[i].cost,ret));
            ret-=k;edge[i].cost-=k;edge[i^1].cost+=k;
        }
    }
    return flow-ret;
}
int dinic(){
    int ans=0;
    while(bfs())ans+=dfs(S,INF);
    return ans;
}
int main(){
    cnt=1;
    memset(head,-1,sizeof(head));
    scanf("%d%d%d%d",&n,&m,&S,&T);
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);add(y,x,0);
    }
    printf("%d\n",dinic());
    return 0;
}
```

### 最小费用最大流

```cpp
#include "stdio.h"
#include "string.h"
#include "algorithm"
#include "iostream"
#include "queue"
using namespace std;
const int maxn=1e5+10;
bool vis[maxn];
int n,m,s,t,x,y,z,f,dis[maxn],pre[maxn],last[maxn],flow[maxn],maxflow,mincost;
//dis最小花费;pre每个点的前驱；last每个点的所连的前一条边；flow源点到此处的流量
struct Edge{
    int to,next,flow,dis;//flow流量 dis花费
}edge[maxn];
int head[maxn],num_edge;
queue <int> q;
void add_edge(int from,int to,int flow,int dis){
    edge[++num_edge].next=head[from];
    edge[num_edge].to=to;
    edge[num_edge].flow=flow;
    edge[num_edge].dis=dis;
    head[from]=num_edge;
}
bool spfa(int s,int t){
    memset(dis,0x7f,sizeof(dis));
    memset(flow,0x7f,sizeof(flow));
    memset(vis,0,sizeof(vis));
    q.push(s); vis[s]=1; dis[s]=0; pre[t]=-1;
    while (!q.empty()){
        int now=q.front();
        q.pop();
        vis[now]=0;
        for (int i=head[now]; i!=-1; i=edge[i].next){
            if (edge[i].flow>0 && dis[edge[i].to]>dis[now]+edge[i].dis){//正边
                dis[edge[i].to]=dis[now]+edge[i].dis;
                pre[edge[i].to]=now;
                last[edge[i].to]=i;
                flow[edge[i].to]=min(flow[now],edge[i].flow);//
                if (!vis[edge[i].to]){
                    vis[edge[i].to]=1;
                    q.push(edge[i].to);
                }
            }
        }
    }
    return pre[t]!=-1;
}
void MCMF(){
    while (spfa(s,t)){
        int now=t;
        maxflow+=flow[t];
        mincost+=flow[t]*dis[t];
        while (now!=s){//从源点一直回溯到汇点
            edge[last[now]].flow-=flow[t];//flow和dis容易搞混
            edge[last[now]^1].flow+=flow[t];
            now=pre[now];
        }
    }
}
int main(){
    memset(head,-1,sizeof(head)); num_edge=-1;//初始化
    scanf("%d%d%d%d",&n,&m,&s,&t);
    for (int i=1; i<=m; i++){
        scanf("%d%d%d%d",&x,&y,&z,&f);
        add_edge(x,y,z,f); add_edge(y,x,0,-f);
        //反边的流量为0，花费是相反数
    }
    MCMF();
    printf("%d %d",maxflow,mincost);
    return 0;
}
```

## bitset在图论

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e5+10;
const int mod=1e9+7;
const int INF=0x3f3f3f3f;
ll read(){
    ll f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
bitset<maxn>f[maxn];//f[i][j]==1表示i和j连通 
int main(){
	for(int i=1;i<=n;i++)f[i].reset();//初始化
	for(int i=1;i<=n;i++){
		f[i][i]=1;
		for(int j=1;j<=n;j++)
			f[i]|=f[j];//将f[j]连通的点连到f[i]上 
	} 
	

/*

也可像二进制数一样直接开始或 异或 与 

b.count();
b中置为1的二进制位的个数
	
b.size();
b中二进制位的个数
	
b[pos];
访问b中在pos处的二进制位
	
b.test(pos)
b中在pos处的二进制位是否为1

b.set()
把b中所有二进制位都置为1

b.set(pos)
把b中在pos处的二进制位置为1

b.reset()
把b中所有二进制位都置为0

b.reset(pos)
把b中在pos处的二进制位置为0

b.flip()
把b中所有二进制位逐位取反

b.flip(pos)
把b中在pos处的二进制位取反

b.to_ulong()
用b中同样的二进制位返回一个unsigned long值
*/
	return 0;
}
```

# 字符串

## KMP

```cpp
#include "stdio.h"
#include "string.h"
#include "algorithm"
#include "iostream"
using namespace std;
const int maxn=1e5+10;
char a[maxn],b[maxn];
int fa[maxn];
void getnext(char *p){
    int i=0,len,k=-1;
    len=strlen(p);fa[0]=-1;
    while(i<len){
        if(k==-1 || p[i]==p[k]){
            i++;k++;fa[i]=k;
        }else k=fa[k];
    }
}
int kmp(char *a,char *b){
    int i=0,j=0;
    int len1=strlen(a),len2=strlen(b);
    getnext(b);
    while(i<len1 && j<len2){
        if(j==-1 || a[i]==b[j])i++,j++;
        else j=fa[j];
    }
    if(j==len2)return i-j;
    else return -1;
}
int main(){
    while(scanf("%s%s",&a,&b)!=EOF){
        if(kmp(a,b)!=-1)printf("%d\n",kmp(a,b));
        else printf("404 not found\n");
    }
    return 0;
}
```

## EXKMP

```cpp
//next[i]表示在s串中以 i 为起点的串的前缀与s串中的前缀最大匹配长度
void getNext(char *s,int next[]){
    int nn = strlen(s);
    next[0] = nn;
    int p = 0;
    while (p+1 < nn && s[p] == s[p+1]) p++;
    next[1] = p;
    int k = 1, L;
    for (int i = 2; i < nn; i++){
        p =     k + next[k] - 1; L = next[i - k];
        if (i + L <= p) next[i] = L;
        else {
            int j = p - i + 1;
            if (j < 0) j = 0;
            while (i + j < nn && s[i + j] == s[j]) j++;
            next[i] = j; k = i;

        }
    }
/*    for (int i=0;i<nn;i++){
        cout<< next[i] <<" ";
    }cout<<endl;
*/
}
//extend[i]表示s[i]...s[n-1]与T的最长相同前缀的长度
void getExtend(char *s,char *T,int extend[]){
    int nn = strlen(s) ,mm = strlen(T);
    getNext(s,next);
    int p = 0;
    while (p < nn && s[p] == T[p]) p++;
    extend[0] = p;
    //extend[1] = p;
    int k = 0, L;
    for (int i = 1; i < nn; i++){
        p =     k + extend[k] - 1; L = next[i - k];
        if (i + L <= p) extend[i] = L;
        else {
            int j = p - i + 1;
            if (j < 0) j = 0;
            while (i + j < nn && s[i + j] == T[j]) j++;
            extend[i] = j; k = i;

        }
    }
/*    for (int i=0;i<nn;i++){
        cout<< extend[i] <<" ";
    }cout<<endl;
*/
}
```

## Trie树

```cpp
//对于字符串比较多的要统计个数的，map被卡的情况下，直接用字典树
//很多题都是要用到节点下标来表示某个字符串
const int maxn =2e6+5;//如果是64MB可以开到2e6+5，尽量开大
int tree[maxn][30];//tree[i][j]表示节点i的第j个儿子的节点编号
bool flagg[maxn];//表示以该节点结尾是一个单词
int tot;//总节点数
int sum[maxn];//sum[rt]表示当前字符串结尾节点的访问次数 
void insert(char *s){
	int len=strlen(s);
	int rt=0;
	for(int i=0;i<len;i++){
		int id=s[i]-'a';
		if(!tree[rt][id])tree[rt][id]=++tot;
		sum[tree[rt][id]]++;
		rt=tree[rt][id]; 
	}
	flagg[rt]=1;
}
int find(char *s){
	int len=strlen(s);
	int rt=0;
	for(int i=0;i<len;i++){
		int id=s[i]-'a';
		if(!tree[rt][id])return 0;
		rt=tree[rt][id];
	}
	return sum[rt];
}
void init()//最后清空，节省时间
{
    for(int i=0;i<=tot;i++)
    {
       flagg[i]=false;
       for(int j=0;j<10;j++)
           tree[i][j]=0;
    }
   tot=0;//RE有可能是这里的问题
}
```

## AC自动机

### 问题描述

![image-20201016135958196](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201016135958196.png)

### fail指针

![image-20201016140036700](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201016140036700.png)

```cpp
void getFail(){
	for(int i=0;i<26;i++)trie[0].son[i]=1;			//初始化0的所有儿子都是1
	q.push(1);trie[1].fail=0;				//将根压入队列
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i<26;i++){				//遍历所有儿子
			int v=trie[u].son[i];			//处理u的i儿子的fail，这样就可以不用记父亲了
			int Fail=trie[u].fail;			//就是fafail，trie[Fail].son[i]就是和v值相同的点
			if(!v){trie[u].son[i]=trie[Fail].son[i];continue;}	//不存在该节点，第二种情况
			trie[v].fail=trie[Fail].son[i];	//第三种情况，直接指就可以了
			q.push(v);						//存在实节点才压入队列
		}
	}
}
```

### 查询

![image-20201016140112538](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201016140112538.png)

```cpp
int query(char* s){
	int u=1,ans=0,len=strlen(s);
	for(int i=0;i<len;i++){
		int v=s[i]-'a';
		int k=trie[u].son[v];		//跳Fail
		while(k>1&&trie[k].flag!=-1){	//经过就不统计了
			ans+=trie[k].flag,trie[k].flag=-1;	//累加上这个位置的模式串个数，标记 已 经过
			k=trie[k].fail;			//继续跳Fail
		}
		u=trie[u].son[v];			//到儿子那,存在性看上面的第二种情况
	}
	return ans;
}
```

### 实现

```cpp
#include<bits/stdc++.h>
#define maxn 1000001
using namespace std;
struct kkk{
	int son[26],flag,fail;
}trie[maxn];
int n,cnt;
char s[1000001];
queue<int >q;
void insert(char* s){
	int u=1,len=strlen(s);
	for(int i=0;i<len;i++){
		int v=s[i]-'a';
		if(!trie[u].son[v])trie[u].son[v]=++cnt;
		u=trie[u].son[v];
	}
	trie[u].flag++;
}
void getFail(){
	for(int i=0;i<26;i++)trie[0].son[i]=1;			//初始化0的所有儿子都是1
	q.push(1);trie[1].fail=0;				//将根压入队列
	while(!q.empty()){
		int u=q.front();q.pop();
		for(int i=0;i<26;i++){				//遍历所有儿子
			int v=trie[u].son[i];			//处理u的i儿子的fail，这样就可以不用记父亲了
			int Fail=trie[u].fail;			//就是fafail，trie[Fail].son[i]就是和v值相同的点
			if(!v){trie[u].son[i]=trie[Fail].son[i];continue;}	//不存在该节点，第二种情况
			trie[v].fail=trie[Fail].son[i];	//第三种情况，直接指就可以了
			q.push(v);						//存在实节点才压入队列
		}
	}
}
int query(char* s){
	int u=1,ans=0,len=strlen(s);
	for(int i=0;i<len;i++){
		int v=s[i]-'a';
		int k=trie[u].son[v];		//跳Fail
		while(k>1&&trie[k].flag!=-1){	//经过就不统计了
			ans+=trie[k].flag,trie[k].flag=-1;	//累加上这个位置的模式串个数，标记已经过
			k=trie[k].fail;			//继续跳Fail
		}
		u=trie[u].son[v];			//到下一个儿子
	}
	return ans;
}
int main(){
	cnt=1;            //代码实现细节，编号从1开始
        scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%s",s);
		insert(s);
	}
	getFail();
	scanf("%s",s);
	printf("%d\n",query(s));
	return 0;
}
/*
//AC自动机加强版
#include<bits/stdc++.h>
#define maxn 1000001
using namespace std;
char s[151][maxn],T[maxn];
int n,cnt,vis[maxn],ans;
struct kkk{
	int son[26],fail,flag;
	void clear(){memset(son,0,sizeof(son));fail=flag=0;}
}trie[maxn];
queue<int>q;
void insert(char* s,int num){
	int u=1,len=strlen(s);
	for(int i=0;i<len;i++){
		int v=s[i]-'a';
		if(!trie[u].son[v])trie[u].son[v]=++cnt;
		u=trie[u].son[v];
	}
	trie[u].flag=num;			//变化1：标记为第num个出现的字符串
}
void getFail(){
	for(int i=0;i<26;i++)trie[0].son[i]=1;
	q.push(1);trie[1].fail=0;
	while(!q.empty()){
		int u=q.front();q.pop();
		int Fail=trie[u].fail;
		for(int i=0;i<26;i++){
			int v=trie[u].son[i];
			if(!v){trie[u].son[i]=trie[Fail].son[i];continue;}
			trie[v].fail=trie[Fail].son[i];
			q.push(v);
		}
	}
}
void query(char* s){
	int u=1,len=strlen(s);
	for(int i=0;i<len;i++){
		int v=s[i]-'a';
		int k=trie[u].son[v];
		while(k>1){
			if(trie[k].flag)vis[trie[k].flag]++;	//如果有模式串标记，更新出现次数
			k=trie[k].fail;
		}
		u=trie[u].son[v];
	}
}
void clear(){
	for(int i=0;i<=cnt;i++)trie[i].clear();
	for(int i=1;i<=n;i++)vis[i]=0;
	cnt=1;ans=0;
}
int main(){
	while(1){
		scanf("%d",&n);if(!n)break;
		clear();
		for(int i=1;i<=n;i++){
			scanf("%s",s[i]);
			insert(s[i],i);
		}
		scanf("%s",T);
		getFail();
		query(T);
		for(int i=1;i<=n;i++)ans=max(vis[i],ans);	//最后统计答案
		printf("%d\n",ans);
		for(int i=1;i<=n;i++)
		if(vis[i]==ans)
		printf("%s\n",s[i]);
	}
}
1、求出现次数最多的次数
2、求出现次数最多的模式串
*/
```



## 马拉车

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
using namespace std;
const int maxn = 1e6 + 5;
char s[maxn * 2], str[maxn * 2];
int Len[maxn * 2], len;
void getstr() {//重定义字符串
	int k = 0;
	str[k++] = '@';//开头加个特殊字符防止越界
	for (int i = 0; i < len; i++) {
		str[k++] = '#';
		str[k++] = s[i];
	}
	str[k++] = '#';
	len = k;
	str[k] = 0;//字符串尾设置为0，防止越界
}
int manacher() {
	int mx = 0, id;//mx为最右边，id为中心点
	int maxx = 0;
	for (int i = 1; i < len; i++) {
		if (mx > i) Len[i] = min(mx - i, Len[2 * id - i]);//判断当前点超没超过mx
		else Len[i] = 1;//超过了就让他等于1，之后再进行查找
		while (str[i + Len[i]] == str[i - Len[i]]) Len[i]++;//判断当前点是不是最长回文子串，不断的向右扩展
		if (Len[i] + i > mx) {//更新mx
			mx = Len[i] + i;
			id = i;//更新中间点
			maxx = max(maxx, Len[i]);//最长回文字串长度
		}
	}
	return (maxx - 1);
}
int main() {
	scanf("%s", s);
	len = strlen(s);
	getstr();
	printf("%d\n",manacher());
	return 0;
}

```



## 回文自动机

```cpp
//徐州网赛G. Colorful String
//求字符串s的所有回文子串价值和
//价值被定义为字符串中包含不同字母的数量 
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
static const int maxn = 300010;
static const int INF = 0x3f3f3f3f;
static const int mod = (int)1e9 + 7;
static const double eps = 1e-6;
static const double pi = acos(-1);
static const int N = 26;

ll ans;
char s[maxn];
struct Palindromic_Tree {
    int next[maxn][N],fail[maxn],cnt[maxn],num[maxn],len[maxn],S[maxn],last,n,p;
    int id[maxn]; 
	int newnode(int l){
        for(int i = 0;i < N;i++)next[p][i] = 0 ;
        cnt[p] = num[p] = 0;
        len[p] = l;
        return p++;
    }
    void init(){
        p = 0;
        newnode(0);
        newnode(-1);
        last = 0;
        n = 0;
        S[n] = -1;
        fail[0] = 1;
    }
    int get_fail(int x){
        while(S[n - len[x] - 1] != S[n])x = fail[x];
        return x;
    }
    void add(int c){
        c -= 'a';
        S[++n] = c;
        int cur = get_fail(last);
        if(!next[cur][c]){
            int now = newnode(len[cur] + 2);
            fail[now] = next[get_fail(fail[cur])][c];
            next[cur][c] = now;
            num[now] = num[fail[now]] + 1;
        }
        last = next[cur][c];
        cnt[last]++;id[last]=n;
    }
    void count(){//主要改cnt 
        for(int i = p - 1;i >= 0;i--)cnt[fail[i]] += cnt[i];
    }
}t;

void dfs(int u,set<char>&s){
    for(int i = 0;i < N;i++){
        int x = t.next[u][i];
        if(x){
            set<char>v;
            v = s;
            v.insert(i);
            ans += t.cnt[x]*v.size();
            dfs(x,v);
        }
    }
}

int main() {
    t.init();
    scanf("%s",s);
    for(int i = 0;s[i];i++)t.add(s[i]);
    t.count();
    set<char>st;
    dfs(0,st);
    dfs(1,st);
    printf("%lld\n",ans);
    return 0;
}
/*以s[i]为结尾的回文串的个数 
t.add(s[0]);printf("%d ",t.num[t.last]);
for(int i = 1;s[i];i++)t.add(s[i]),printf("%d ",t.num[t.last]); 
*/
/*所有回文串中不同字符数量之和 
for(int i = 0;s[i];i++)t.add(s[i]);
t.count();
set<char>st;
dfs(0,st);
dfs(1,st);
printf("%lld\n",ans);
*/
/*所有回文串出现次数*长度 
for(int i=0;s[i];i++)t.add(s[i]);
t.count();
for(int i=t.p;i>=0;i--)ans=max(ans,1ll*t.cnt[i]*t.len[i]);
*/

/*
 int next[MAXN][N] ;//next指针，next指针和字典树类似，指向的串为当前串两端加上同一个字符构成
    int fail[MAXN] ;//fail指针，失配后跳转到fail指针指向的节点
    int cnt[MAXN] ; //表示节点i表示的本质不同的串的个数（建树时求出的不是完全的，最后count()函数跑一遍以后才是正确的）
    int num[MAXN] ; //表示以节点i表示的回文串的最右端点为回文串结尾的回文串个数
    int len[MAXN] ;//len[i]表示节点i表示的回文串的长度（一个节点表示一个回文串）
    int S[MAXN] ;//存放添加的字符
    int last_pos[MAXN];//存放回文串结尾的位置
    //int id[MAXN];//回文子串结尾的地方+1 ,与last_pos功能一样
    int last ;//指向新添加一个字母后所形成的最长回文串表示的节点。
    int n ;//表示添加的字符个数。
    int p ;//表示添加的节点个数。求不同回文串的个数=p-2（要跑count函数）
*/
```
## 字符串哈希
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int maxn=1e5+10;
const int mod=1e9+7;
const int INF=0x3f3f3f3f;
ll read(){
    ll f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
ull h1[maxn],h2[maxn];
ull base=147;
char s[maxn];
void gethash(int len){
	h1[0]=1;h2[0]=1;
	for(int i=1;i<=len;i++)
		h1[i]=h1[i-1]*base+(s[i-1]-'a'),h2[i]=h2[i-1]*base;
}
ull usehash(int l,int r){
	return h1[r]-h1[l-1]*h2[r-l+1];
}
int main(){
	scanf("%s",&s);
	gethash(strlen(s)); 
	return 0;
}

```

# 其他

## Zeller公式

```cpp
//年月日求星期几
int Day(int year, int month, int day){
	int ret = 0;
	int c, y, m, d;
	if(month <= 2){
		c = ( year - 1 ) / 100;
		y = ( year - 1 ) % 100;
		m = month + 12;
		d = day;
	}
	else{
		c = year / 100;
		y = year % 100;
		m = month;
		d = day;
	}
	ret = y + y / 4 + c / 4 - 2 * c + 26 * ( m + 1 ) / 10 + d - 1;
	ret = ret >= 0 ? ( ret % 7 ) : ( ret % 7 + 7 );
	if(ret == 0){
		ret = 7;
	}
	return ret;
}
```

## 二维差分数组和前缀和

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e5+10;
const int mod=1e9+7;
const int INF=0x3f3f3f3f;
const int N=2e5+10;
const int Maxn=5e5+10;
const double eps=1e-6;
const ll inf=1e18;
ll read(){
    ll f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
int n,m,a,b;
int s[4000][4000],t[4000][4000];
int f[4000][4000];
int main(){
	scanf("%d%d%d%d",&n,&m,&a,&b);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			int x;
			scanf("%d",&x);
			if(x==1){
				f[i][j]+=1;
				f[i][b-m+j+1]-=1;
				f[a-n+i+1][j]-=1;
				f[a-n+i+1][b-m+j+1]+=1;
			}
		}
	for(int i=1;i<=a;i++)
		for(int j=1;j<=b;j++)
			t[i][j]=t[i][j-1]+t[i-1][j]-t[i-1][j-1]+f[i][j];
	int sum=0;
	for(int i=1;i<=a;i++)
		for(int j=1;j<=b;j++)
			sum=max(sum,t[i][j]);
	for(int i=1;i<=a;i++){
		for(int j=1;j<b;j++){
			printf("%d ",int((1.0*t[i][j]/(1.0*sum))*100));
		}
		printf("%d\n",int((1.0*t[i][b]/(1.0*sum))*100));
	}
	return 0;
}
```

## 高精度

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e5+10;
const int mod=1e9+7;
const int INF=0x3f3f3f3f;
ll read(){
    ll f=1,x=0;char ch;
    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');
    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');
    return f*x;
}
struct BigN{
	int c,s[maxn];
	char a[maxn];
	int len;
	BigN(){}
	void operator =(int x){
		c=0;len=0;
		memset(s,0,sizeof(s));
		while(x)s[c++]=x%10,x/=10;
		for(int i=c;i>0;i--)a[len++]=s[i]+'0';
	}
	void put(){
		for(int i=1;i<50 && i<=c;i++)printf("%d",s[c-i]);
		printf("\n");
	}
}num[3];
void add(const BigN& a,const BigN& b,BigN& ans){
	int tmp=0;
	ans.c=max(a.c,b.c);
	for(int i=max(min(a.c,b.c)-50,0);i<a.c || i<b.c;i++){
		if(i<a.c)tmp+=a.s[i];
		if(i<b.c)tmp+=b.s[i];
		ans.s[i]=tmp%10;
		tmp/=10;
	}
	while(tmp){
		ans.s[ans.c++]=tmp%10;
		tmp/=10;
	}
	ans.len=0;
	for(int i=ans.c-1;i>=0;i--)ans.a[ans.len++]=ans.s[i]+'0';
}
string add(string a,string b){
	v.clear();
	int tmp=0,t=0;
	reverse(a.begin(),a.end());
	reverse(b.begin(),b.end());
	while(a.size()!=b.size()){
		if(a.size()>b.size())b.push_back('0');
		else a.push_back('0');
	}
	for(int i=0;i<a.size();i++){
		tmp=a[i]+b[i]-'0'*2+t;
		t=tmp/10;
		v.push_back(tmp%10+'0');
	}
	if(t>0)v.push_back(t+'0');
	reverse(v.begin(),v.end());
	return v;
}
int main(){
	return 0;
}
/*
无限循环小数转换成分数 就是将循环节比上999999
*/ 
```

```java
import java.math.*;
import java.util.*;
public class Main {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner input=new Scanner(System.in);
		BigInteger []m=new BigInteger[200];
		m[0]=BigInteger.valueOf(4);
		m[1]=BigInteger.valueOf(14);
		for(int i=2;i<180;i++)
			m[i]=m[i-1].multiply(BigInteger.valueOf(4)).subtract(m[i-2]);
		//a.add(),a.subtract(),a.multiply(),a.divide()zhengchu,a.remainder()quyu,a.pow()mi,a.compareTo()bijiao
		int t;
		t=input.nextInt();
		for(int i=0;i<t;i++) {
			BigInteger N;
			N=input.nextBigInteger();
			for(int j=0;j<180;j++) {
				if(m[j].compareTo(N)>=0) {
					System.out.println(m[j]);
					break;
				}
			}
				
		}

	}

}
```

## 滑动窗口

```cpp
class Solution {
public:
    vector<int> maxInWindows(vector<int>& nums, int k) {
        deque<int>q;
        vector<int>res;
        for(int i=0;i<nums.size();i++)
        {
             while(q.size()&&q.front()<=i-k)q.pop_front();//记录的是坐标整个双端队列是单调递减的
             while(q.size()&&nums[q.back()]<nums[i])q.pop_back();
             q.push_back(i);//每次先插进去，不符合条件再弹出来
             if(i>=k-1)res.push_back(nums[q.front()]);
        }
        return res;
    }
};
```

## 尺取法

```cpp
 int st=1,ed=1,sum=1,ans=INF;
        mp[f[1].pos]=1;
        while(true){	
            while(ed<cnt && sum<n){
                if(mp[f[ed+1].pos]==0){
                    sum++;
                }
                mp[f[ed+1].pos]++;
                ed++;
            }
            if(sum<n)break;
            ans=min(ans,f[ed].val-f[st].val);
            if(mp[f[st].pos]-1==0){
                sum--;
            }
            mp[f[st].pos]--;
            st++;
        }
        printf("%d\n",ans);
```



## 矩阵树 变元矩阵树

```cpp
#include "stdio.h"
#include "string.h"
#include "iostream"
#include "algorithm"
#include "math.h"
#include "queue"
#include "vector"
#include "stack"
#include "set"
#include "map"
#include "unordered_map"
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int INF=0x3f3f3f3f;
const ll mod=998244353;
const int MOD=998244353;
const ll inf=1e18;
const int maxn=5e5+10;
const ull base=147;
int n,m;
ll gcd(ll a, ll b){
    return b==0?a:gcd(b,a%b);
}
ll a[40][110][110],d[40][110][110];
ll f[40][110][110];
ll gauss(int tt){
    ll ans=1;
    for(int i=1;i<n;i++){
        for(int j=i+1;j<n;j++){
            while(f[tt][j][i]){
                ll t=f[tt][i][i]/f[tt][j][i];
                for(int k=i;k<n;k++)
                    f[tt][i][k]=(f[tt][i][k]-t*f[tt][j][k]%mod+mod)%mod;
                swap(f[tt][i],f[tt][j]);
                ans=-ans;
            }
        }
        ans=(ans*f[tt][i][i])%mod;
    }
    return (ans+mod)%mod;
}
ll quick(ll a,ll b){
    ll res=1;
    while(b){
        if(b&1)res=res*a%mod;
        a=a*a%mod;
        b>>=1;
    }
    return res;
}
int main(){
    int T;
    scanf("%d",&T);
    while(T--){
        memset(d,0,sizeof(d));
        memset(a,0,sizeof(a));
        memset(f,0,sizeof(f));
        scanf("%d%d",&n,&m);
        for(int i=1;i<=m;i++){
            int u,v,w;
            scanf("%d%d%d",&u,&v,&w);
            a[0][u][v]++;
            a[0][v][u]++;
            int tot=0;
            while(w){
                int x=w%2;tot++;w/=2;
                if(x==1){
                    a[tot][u][v]++;
                    a[tot][v][u]++;
                }
            }
        }
        /*
        =变元矩阵树
            定义Kirchhoff矩阵𝐾，其中
            𝐾𝑖𝑖为所有与𝑖相连的边的权值和
            𝐾𝑖𝑗为连接𝑖与𝑗的边权值和的负值
            求完全图中最小生成树的权值和
        矩阵树
            𝐾𝑖𝑖 定义为𝑖的度数
            𝐾𝑖𝑗定义为𝑖是否𝑗相连(是则为−1，否则为0)
            求完全图中最小生成树的个数
        */
        for(int i=0;i<32;i++)
            for(int j=1;j<=n;j++)
                for(int k=1;k<=n;k++)
                    d[i][j][j]+=a[i][j][k];
        for(int i=0;i<32;i++)
            for(int j=1;j<=n;j++)
                for(int k=1;k<=n;k++)
                    f[i][j][k]=d[i][j][k]-a[i][j][k];
        ll ds=gauss(0);
        ll ans=0,dd=1;
        for(int i=1;i<32;i++){
            ll t=gauss(i);//答案
            ans=(ans+dd*t)%mod;
            dd=dd*2%mod;
        }
        ll gg=gcd(ans,ds);
        ans/=gg;ds/=gg;
        printf("%lld\n",ans*quick(ds,mod-2)%mod);
    }
    return 0;
}
```

## 爬山算法

![image-20201015204152684](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201015204152684.png)

```cpp
#include <bits/stdc++.h>
using namespace std;
double ans[10001], cans[100001], dis[10001], tot, f[1001][1001];
int n;
double check() {
  tot = 0;
  for (int i = 1; i <= n + 1; i++) {
    dis[i] = 0;
    cans[i] = 0;
    for (int j = 1; j <= n; j++)
      dis[i] += (f[i][j] - ans[j]) * (f[i][j] - ans[j]);
    dis[i] = sqrt(dis[i]);  // 欧氏距离
    tot += dis[i];
  }
  tot /= (n + 1);  // 平均
  for (int i = 1; i <= n + 1; i++)
    for (int j = 1; j <= n; j++)
      cans[j] += (dis[i] - tot) * (f[i][j] - ans[j]) /
                 tot;  // 对于每个维度把修改值更新掉，欧氏距离差*差值贡献
}
int main() {
  cin >> n;
  for (int i = 1; i <= n + 1; i++)
    for (int j = 1; j <= n; j++) {
      cin >> f[i][j];
      ans[j] += f[i][j];
    }
  for (int i = 1; i <= n; i++) ans[i] /= (n + 1);      // 初始化
  for (double t = 10001; t >= 0.0001; t *= 0.99995) {  // 不断降温
    check();
    for (int i = 1; i <= n; i++) ans[i] += cans[i] * t;  // 修改
  }
  for (int i = 1; i <= n; i++) printf("%.3f ", ans[i]);
}
```

![image-20201015204213236](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201015204213236.png)

## 模拟退火

![image-20201015165754775](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201015165754775.png)

```cpp
inline void fire(){
	double x=ansx,y=ansy;
	double T=max_temperature,delta=change_temperature;
	while (T>=min_temperature){
		register double xx=ansx+(rand()*2-RAND_MAX)*T;
		register double yy=ansy+(rand()*2-RAND_MAX)*T;
		register double nowans=calc(xx,yy);
		register double DE=nowans-ans;
		if (DE<0){
			ans=nowans;
			x=ansx=xx;y=ansy=yy;
		}
		else if (exp(-DE/T)*RAND_MAX>rand()) x=xx,y=yy;
		T*=delta;
	}
}
/*
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cmath>
using namespace std;
const int N=110;

int t,n;
int px[N],py[N];
double ansx,ansy,ansdis;

inline int re(){
	register int x=0;register char ch=getchar();
	while (ch<'0'||ch>'9')ch=getchar(); while (ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();
	return x;
}

inline double calc(double x,double y,double xx,double yy){
	return sqrt((x-xx)*(x-xx)+(y-yy)*(y-yy));
}

inline double query(double x,double y){
	register double sum=0;
	for (int i=1;i<=n;++i) sum+=calc(x,y,(double)px[i],(double)py[i]);
	return sum;
}

inline void fire(){
	double x=ansx,y=ansy;
	double T=2333,delta=0.994;
	while (T>=1e-10){
		register double xx=ansx+(rand()*2-RAND_MAX)*T;
		register double yy=ansy+(rand()*2-RAND_MAX)*T;
		register double nowans=query(xx,yy);
		register double DE=nowans-ansdis;
		if (DE<0) ansdis=nowans,x=ansx=xx,y=ansy=yy;
		else if (exp(-DE/T)*RAND_MAX>rand()) x=xx,y=yy;
		T*=delta;
	}
}

void work(){
	ansx=0;ansy=0;n=re();
	for (int i=1;i<=n;++i) ansx+=(px[i]=re()),ansy+=(py[i]=re());
	ansx/=(double)n;ansy/=(double)n;
	ansdis=query(ansx,ansy);
	fire();
	printf("%.0lf\n",ansdis);
}

int main(){
	t=re();
	for (int i=1;i<=t;++i){
		work();
		if (i^t) printf("\n");
	}
	return 0;
}
*/
```

## 莫队

### 普通莫队

![image-20201015171631306](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201015171631306.png)

```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
using namespace std;
const int N = 50005;
int n, m, maxn;
int c[N];
long long sum;
int cnt[N];
long long ans1[N], ans2[N];
struct query {
  int l, r, id;
  bool operator<(const query &x) const {
    if (l / maxn != x.l / maxn) return l < x.l;
    return (l / maxn) & 1 ? r < x.r : r > x.r;
  }
} a[N];
void add(int i) {
  sum += cnt[i];
  cnt[i]++;
}
void del(int i) {
  cnt[i]--;
  sum -= cnt[i];
}
long long gcd(long long a, long long b) { return b ? gcd(b, a % b) : a; }
int main() {
  scanf("%d%d", &n, &m);
  maxn = sqrt(n);
  for (int i = 1; i <= n; i++) scanf("%d", &c[i]);
  for (int i = 0; i < m; i++) scanf("%d%d", &a[i].l, &a[i].r), a[i].id = i;
  sort(a, a + m);
  for (int i = 0, l = 1, r = 0; i < m; i++) {
    if (a[i].l == a[i].r) {
      ans1[a[i].id] = 0, ans2[a[i].id] = 1;
      continue;
    }
    while (l > a[i].l) add(c[--l]);
    while (r < a[i].r) add(c[++r]);
    while (l < a[i].l) del(c[l++]);
    while (r > a[i].r) del(c[r--]);
    ans1[a[i].id] = sum;
    ans2[a[i].id] = (long long)(r - l + 1) * (r - l) / 2;
  }
  for (int i = 0; i < m; i++) {
    if (ans1[i] != 0) {
      long long g = gcd(ans1[i], ans2[i]);
      ans1[i] /= g, ans2[i] /= g;
    } else
      ans2[i] = 1;
    printf("%lld/%lld\n", ans1[i], ans2[i]);
  }
  return 0;
}
/*
inline void move(int pos, int sign) {
  // update nowAns
}

void solve() {
  BLOCK_SIZE = int(ceil(pow(n, 0.5)));
  sort(querys, querys + m);
  for (int i = 0; i < m; ++i) {
    const query &q = querys[i];
    while (l > q.l) move(--l, 1);
    while (r < q.r) move(r++, 1);
    while (l < q.l) move(l++, -1);
    while (r > q.r) move(--r, -1);
    ans[q.id] = nowAns;
  }
}
*/
```

### 带修莫队

![image-20201015202926206](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201015202926206.png)

![image-20201015202956142](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201015202956142.png)

```cpp
#include <bits/stdc++.h>
#define SZ (10005)
using namespace std;
template <typename _Tp>
inline void IN(_Tp& dig) {
  char c;
  dig = 0;
  while (c = getchar(), !isdigit(c))
    ;
  while (isdigit(c)) dig = dig * 10 + c - '0', c = getchar();
}
int n, m, sqn, c[SZ], ct[SZ], c1, c2, mem[SZ][3], ans, tot[1000005], nal[SZ];
struct query {
  int l, r, i, c;
  bool operator<(const query another) const {
    if (l / sqn == another.l / sqn) {
      if (r / sqn == another.r / sqn) return i < another.i;
      return r < another.r;
    }
    return l < another.l;
  }
} Q[SZ];
void add(int a) {
  if (!tot[a]) ans++;
  tot[a]++;
}
void del(int a) {
  tot[a]--;
  if (!tot[a]) ans--;
}
char opt[10];
int main() {
  IN(n), IN(m), sqn = pow(n, (double)2 / (double)3);
  for (int i = 1; i <= n; i++) IN(c[i]), ct[i] = c[i];
  for (int i = 1, a, b; i <= m; i++)
    if (scanf("%s", opt), IN(a), IN(b), opt[0] == 'Q')
      Q[c1].l = a, Q[c1].r = b, Q[c1].i = c1, Q[c1].c = c2, c1++;
    else
      mem[c2][0] = a, mem[c2][1] = ct[a], mem[c2][2] = ct[a] = b, c2++;
  sort(Q, Q + c1), add(c[1]);
  int l = 1, r = 1, lst = 0;
  for (int i = 0; i < c1; i++) {
    for (; lst < Q[i].c; lst++) {
      if (l <= mem[lst][0] && mem[lst][0] <= r)
        del(mem[lst][1]), add(mem[lst][2]);
      c[mem[lst][0]] = mem[lst][2];
    }
    for (; lst > Q[i].c; lst--) {
      if (l <= mem[lst - 1][0] && mem[lst - 1][0] <= r)
        del(mem[lst - 1][2]), add(mem[lst - 1][1]);
      c[mem[lst - 1][0]] = mem[lst - 1][1];
    }
    for (++r; r <= Q[i].r; r++) add(c[r]);
    for (--r; r > Q[i].r; r--) del(c[r]);
    for (--l; l >= Q[i].l; l--) add(c[l]);
    for (++l; l < Q[i].l; l++) del(c[l]);
    nal[Q[i].i] = ans;
  }
  for (int i = 0; i < c1; i++) printf("%d\n", nal[i]);
  return 0;
}
```

### 树上莫队

#### 括号树上莫队

![image-20201015203607144](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201015203607144.png)

![image-20201015203625820](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201015203625820.png)

```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
using namespace std;

const int maxn = 200010;

int f[maxn], g[maxn], id[maxn], head[maxn], cnt, last[maxn], dep[maxn],
    fa[maxn][22], v[maxn], w[maxn];
int block, index, n, m, q;
int pos[maxn], col[maxn], app[maxn];
bool vis[maxn];
long long ans[maxn], cur;

struct edge {
  int to, nxt;
} e[maxn];
int cnt1 = 0, cnt2 = 0;  // 时间戳

struct query {
  int l, r, t, id;
  bool operator<(const query &b) const {
    return (pos[l] < pos[b.l]) || (pos[l] == pos[b.l] && pos[r] < pos[b.r]) ||
           (pos[l] == pos[b.l] && pos[r] == pos[b.r] && t < b.t);
  }
} a[maxn], b[maxn];

inline void addedge(int x, int y) {
  e[++cnt] = (edge){y, head[x]};
  head[x] = cnt;
}

void dfs(int x) {
  id[f[x] = ++index] = x;
  for (int i = head[x]; i; i = e[i].nxt) {
    if (e[i].to != fa[x][0]) {
      fa[e[i].to][0] = x;
      dep[e[i].to] = dep[x] + 1;
      dfs(e[i].to);
    }
  }
  id[g[x] = ++index] = x;  // 括号序
}

inline int lca(int x, int y) {
  if (dep[x] < dep[y]) swap(x, y);
  if (dep[x] != dep[y]) {
    int dis = dep[x] - dep[y];
    for (int i = 20; i >= 0; i--)
      if (dis >= (1 << i)) dis -= 1 << i, x = fa[x][i];
  }  // 爬到同一高度
  if (x == y) return x;
  for (int i = 20; i >= 0; i--) {
    if (fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];
  }
  return fa[x][0];
}

inline void add(int x) {
  if (vis[x])
    cur -= (long long)v[col[x]] * w[app[col[x]]--];
  else
    cur += (long long)v[col[x]] * w[++app[col[x]]];
  vis[x] ^= 1;
}

inline void modify(int x, int t) {
  if (vis[x]) {
    add(x);
    col[x] = t;
    add(x);
  } else
    col[x] = t;
}  // 在时间维上移动

int main() {
  scanf("%d%d%d", &n, &m, &q);
  for (int i = 1; i <= m; i++) scanf("%d", &v[i]);
  for (int i = 1; i <= n; i++) scanf("%d", &w[i]);
  for (int i = 1; i < n; i++) {
    int x, y;
    scanf("%d%d", &x, &y);
    addedge(x, y);
    addedge(y, x);
  }
  for (int i = 1; i <= n; i++) {
    scanf("%d", &last[i]);
    col[i] = last[i];
  }
  dfs(1);
  for (int j = 1; j <= 20; j++)
    for (int i = 1; i <= n; i++)
      fa[i][j] = fa[fa[i][j - 1]][j - 1];  // 预处理祖先
  int block = pow(index, 2.0 / 3);
  for (int i = 1; i <= index; i++) {
    pos[i] = (i - 1) / block;
  }
  while (q--) {
    int opt, x, y;
    scanf("%d%d%d", &opt, &x, &y);
    if (opt == 0) {
      b[++cnt2].l = x;
      b[cnt2].r = last[x];
      last[x] = b[cnt2].t = y;
    } else {
      if (f[x] > f[y]) swap(x, y);
      a[++cnt1] = (query){lca(x, y) == x ? f[x] : g[x], f[y], cnt2, cnt1};
    }
  }
  sort(a + 1, a + cnt1 + 1);
  int L, R, T;  // 指针坐标
  L = R = 0;
  T = 1;
  for (int i = 1; i <= cnt1; i++) {
    while (T <= a[i].t) {
      modify(b[T].l, b[T].t);
      T++;
    }
    while (T > a[i].t) {
      modify(b[T].l, b[T].r);
      T--;
    }
    while (L > a[i].l) {
      L--;
      add(id[L]);
    }
    while (L < a[i].l) {
      add(id[L]);
      L++;
    }
    while (R > a[i].r) {
      add(id[R]);
      R--;
    }
    while (R < a[i].r) {
      R++;
      add(id[R]);
    }
    int x = id[L], y = id[R];
    int llca = lca(x, y);
    if (x != llca && y != llca) {
      add(llca);
      ans[a[i].id] = cur;
      add(llca);
    } else
      ans[a[i].id] = cur;
  }
  for (int i = 1; i <= cnt1; i++) {
    printf("%lld\n", ans[i]);
  }
  return 0;
}
```

#### 真正的树上莫队

![image-20201015203737397](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201015203737397.png)

![image-20201015203808965](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201015203808965.png)

![image-20201015203819681](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201015203819681.png)

```cpp
#include <bits/stdc++.h>
using namespace std;
inline int gi() {
  register int x, c, op = 1;
  while (c = getchar(), c < '0' || c > '9')
    if (c == '-') op = -op;
  x = c ^ 48;
  while (c = getchar(), c >= '0' && c <= '9')
    x = (x << 3) + (x << 1) + (c ^ 48);
  return x * op;
}
int head[100002], nxt[200004], ver[200004], tot = 0;
void add(int x, int y) {
  ver[++tot] = y, nxt[tot] = head[x], head[x] = tot;
  ver[++tot] = x, nxt[tot] = head[y], head[y] = tot;
}
int bl[100002], bls = 0;
unsigned step;
int fa[100002], dp[100002], hs[100002] = {0}, sz[100002] = {0}, top[100002],
                            id[100002];
stack<int> sta;
void dfs1(int x) {
  sz[x] = 1;
  unsigned ss = sta.size();
  for (int i = head[x]; i; i = nxt[i])
    if (ver[i] != fa[x]) {
      fa[ver[i]] = x, dp[ver[i]] = dp[x] + 1;
      dfs1(ver[i]);
      sz[x] += sz[ver[i]];
      if (sz[ver[i]] > sz[hs[x]]) hs[x] = ver[i];
      if (sta.size() - ss >= step) {
        bls++;
        while (sta.size() != ss) bl[sta.top()] = bls, sta.pop();
      }
    }
  sta.push(x);
}
int cnt = 0;
void dfs2(int x, int hf) {
  top[x] = hf, id[x] = ++cnt;
  if (!hs[x]) return;
  dfs2(hs[x], hf);
  for (int i = head[x]; i; i = nxt[i])
    if (ver[i] != fa[x] && ver[i] != hs[x]) dfs2(ver[i], ver[i]);
}
int lca(int x, int y) {
  while (top[x] != top[y]) {
    if (dp[top[x]] < dp[top[y]]) swap(x, y);
    x = fa[top[x]];
  }
  return dp[x] < dp[y] ? x : y;
}
struct qu {
  int x, y, t, id;
  bool operator<(const qu a) const {
    return bl[x] == bl[a.x] ? (bl[y] == bl[a.y] ? t < a.t : bl[y] < bl[a.y])
                            : bl[x] < bl[a.x];
  }
} q[100001];
int qs = 0;
struct ch {
  int x, y, b;
} upd[100001];
int ups = 0;
long long ans[100001];
int b[100001] = {0};
int a[100001];
long long w[100001];
long long v[100001];
long long now = 0;
bool vis[100001] = {0};
void back(int t) {
  if (vis[upd[t].x]) {
    now -= w[b[upd[t].y]--] * v[upd[t].y];
    now += w[++b[upd[t].b]] * v[upd[t].b];
  }
  a[upd[t].x] = upd[t].b;
}
void change(int t) {
  if (vis[upd[t].x]) {
    now -= w[b[upd[t].b]--] * v[upd[t].b];
    now += w[++b[upd[t].y]] * v[upd[t].y];
  }
  a[upd[t].x] = upd[t].y;
}
void update(int x) {
  if (vis[x])
    now -= w[b[a[x]]--] * v[a[x]];
  else
    now += w[++b[a[x]]] * v[a[x]];
  vis[x] ^= 1;
}
void move(int x, int y) {
  if (dp[x] < dp[y]) swap(x, y);
  while (dp[x] > dp[y]) update(x), x = fa[x];
  while (x != y) update(x), update(y), x = fa[x], y = fa[y];
}
int main() {
  int n = gi(), m = gi(), k = gi();
  step = (int)pow(n, 0.6);
  for (int i = 1; i <= m; i++) v[i] = gi();
  for (int i = 1; i <= n; i++) w[i] = gi();
  for (int i = 1; i < n; i++) add(gi(), gi());
  for (int i = 1; i <= n; i++) a[i] = gi();
  for (int i = 1; i <= k; i++)
    if (gi())
      q[++qs].x = gi(), q[qs].y = gi(), q[qs].t = ups, q[qs].id = qs;
    else
      upd[++ups].x = gi(), upd[ups].y = gi();
  for (int i = 1; i <= ups; i++) upd[i].b = a[upd[i].x], a[upd[i].x] = upd[i].y;
  for (int i = ups; i; i--) back(i);
  fa[1] = 1;
  dfs1(1), dfs2(1, 1);
  if (!sta.empty()) {
    bls++;
    while (!sta.empty()) bl[sta.top()] = bls, sta.pop();
  }
  for (int i = 1; i <= n; i++)
    if (id[q[i].x] > id[q[i].y]) swap(q[i].x, q[i].y);
  sort(q + 1, q + qs + 1);
  int x = 1, y = 1, t = 0;
  for (int i = 1; i <= qs; i++) {
    if (x != q[i].x) move(x, q[i].x), x = q[i].x;
    if (y != q[i].y) move(y, q[i].y), y = q[i].y;
    int f = lca(x, y);
    update(f);
    while (t < q[i].t) change(++t);
    while (t > q[i].t) back(t--);
    ans[q[i].id] = now;
    update(f);
  }
  for (int i = 1; i <= qs; i++) printf("%lld\n", ans[i]);
  return 0;
}
```

### 回滚莫队

![image-20201015203908139](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201015203908139.png)

![image-20201015203917029](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201015203917029.png)

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 5;
int n, q;
int x[N], t[N], m;

struct Query {
  int l, r, id;
} Q[N];
int pos[N], L[N], R[N], sz, tot;
int cnt[N], __cnt[N];
ll ans[N];

inline bool cmp(const Query& A, const Query& B) {
  if (pos[A.l] == pos[B.l]) return A.r < B.r;
  return pos[A.l] < pos[B.l];
}

void build() {
  sz = sqrt(n);
  tot = n / sz;
  for (int i = 1; i <= tot; i++) {
    L[i] = (i - 1) * sz + 1;
    R[i] = i * sz;
  }
  if (R[tot] < n) {
    ++tot;
    L[tot] = R[tot - 1] + 1;
    R[tot] = n;
  }
}

inline void Add(int v, ll& Ans) {
  ++cnt[v];
  Ans = max(Ans, 1LL * cnt[v] * t[v]);
}

inline void Del(int v) { --cnt[v]; }

int main() {
  scanf("%d %d", &n, &q);
  for (int i = 1; i <= n; i++) scanf("%d", &x[i]), t[++m] = x[i];
  for (int i = 1; i <= q; i++) scanf("%d %d", &Q[i].l, &Q[i].r), Q[i].id = i;

  build();

  // 对询问进行排序
  for (int i = 1; i <= tot; i++)
    for (int j = L[i]; j <= R[i]; j++) pos[j] = i;
  sort(Q + 1, Q + 1 + q, cmp);

  // 离散化
  sort(t + 1, t + 1 + m);
  m = unique(t + 1, t + 1 + m) - (t + 1);
  for (int i = 1; i <= n; i++) x[i] = lower_bound(t + 1, t + 1 + m, x[i]) - t;

  int l = 1, r = 0, last_block = 0, __l;
  ll Ans = 0, tmp;
  for (int i = 1; i <= q; i++) {
    // 询问的左右端点同属于一个块则暴力扫描回答
    if (pos[Q[i].l] == pos[Q[i].r]) {
      for (int j = Q[i].l; j <= Q[i].r; j++) ++__cnt[x[j]];
      for (int j = Q[i].l; j <= Q[i].r; j++)
        ans[Q[i].id] = max(ans[Q[i].id], 1LL * t[x[j]] * __cnt[x[j]]);
      for (int j = Q[i].l; j <= Q[i].r; j++) --__cnt[x[j]];
      continue;
    }

    // 访问到了新的块则重新初始化莫队区间
    if (pos[Q[i].l] != last_block) {
      while (r > R[pos[Q[i].l]]) Del(x[r]), --r;
      while (l < R[pos[Q[i].l]] + 1) Del(x[l]), ++l;
      Ans = 0;
      last_block = pos[Q[i].l];
    }

    // 扩展右端点
    while (r < Q[i].r) ++r, Add(x[r], Ans);
    __l = l;
    tmp = Ans;

    // 扩展左端点
    while (__l > Q[i].l) --__l, Add(x[__l], tmp);
    ans[Q[i].id] = tmp;

    // 回滚
    while (__l < l) Del(x[__l]), ++__l;
  }
  for (int i = 1; i <= q; i++) printf("%lld\n", ans[i]);
  return 0;
}
```

### 莫队里的bitset

![image-20201015203949874](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201015203949874.png)

```cpp
#include <algorithm>
#include <bitset>
#include <cmath>
#include <cstdio>
#include <cstring>
using namespace std;
const int N = 100005, M = N / 3 + 10;
int n, m, maxn;
int a[N], ans[M], cnt[N];
bitset<N> sum[M], now;
struct query {
  int l, r, id;
  bool operator<(const query& x) const {
    if (l / maxn != x.l / maxn) return l < x.l;
    return (l / maxn) & 1 ? r < x.r : r > x.r;
  }
} q[M * 3];
void static_set() {
  static int tmp[N];
  memcpy(tmp, a, sizeof(a));
  sort(tmp + 1, tmp + n + 1);
  for (int i = 1; i <= n; i++)
    a[i] = lower_bound(tmp + 1, tmp + n + 1, a[i]) - tmp;
}
void add(int x) {
  now.set(x + cnt[x]);
  cnt[x]++;
}
void del(int x) {
  cnt[x]--;
  now.reset(x + cnt[x]);
}
void solve() {
  int cnt = 0, tot = 0;
  now.reset();
  for (tot = 0; tot < M - 5 && m; tot++) {
    m--;
    ans[tot] = 0;
    sum[tot].set();
    for (int j = 0; j < 3; j++) {
      scanf("%d%d", &q[cnt].l, &q[cnt].r);
      q[cnt].id = tot;
      ans[tot] += q[cnt].r - q[cnt].l + 1;
      cnt++;
    }
  }
  sort(q, q + cnt);
  for (int i = 0, l = 1, r = 0; i < cnt; i++) {
    while (l > q[i].l) add(a[--l]);
    while (r < q[i].r) add(a[++r]);
    while (l < q[i].l) del(a[l++]);
    while (r > q[i].r) del(a[r--]);
    sum[q[i].id] &= now;
  }
  for (int i = 0; i < tot; i++)
    printf("%d\n", ans[i] - (int)sum[i].count() * 3);
}
int main() {
  scanf("%d%d", &n, &m);
  for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
  static_set();
  maxn = sqrt(n);
  solve();
  memset(cnt, 0, sizeof(cnt));
  solve();
  memset(cnt, 0, sizeof(cnt));
  solve();
  return 0;
}
```

## 斐波那契数列

### 基本性质

![image-20201016142639532](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201016142639532.png)

### 通项公式

![image-20201016142711909](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201016142711909.png)

### 矩阵快速幂

```cpp
#include<stdio.h>
#include<string.h>
#include<iostream>
#include<algorithm>
#include<math.h>
using namespace std;
struct arr{
    long long a[2][2];
}ans,shu,mp,bz;
int T;
long long n,a,b,c,p;
long long quick(long long a,long long b){
    long long ans=1;
    while(b){
        if(b&1)ans=ans*a%p;
        a=a*a%p;
        b>>=1;
    }
    return ans;
}
arr matrix(arr x,arr y){
    for(int i=0;i<2;i++)
        for(int j=0;j<2;j++){
            mp.a[i][j]=0;
            for(int k=0;k<2;k++)
                mp.a[i][j]=(mp.a[i][j]+x.a[i][k]*y.a[k][j])%(p);
        }
    return mp;
}
long long work(long long k){
    ans={1,0,0,1};
    while(k){
        if(k&1)ans=matrix(ans,shu);
        k>>=1;
        shu=matrix(shu,shu);
    }
    return (ans.a[0][1]+ans.a[1][1])%7;
}
int main(){
    p=7;
    while(~scanf("%d%d%d",&a,&b,&c) && a && b && c){
        if(c==1)printf("1\n");
        if(c==2)printf("1\n");
        if(c>=3){
            shu={a,1,b,0};
            printf("%lld\n",work(c-1));
        }
    }
    return 0;
}

//快速求fib数列
```

### 求循环节长度

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long LL;
const LL maxn=1e5+5;
LL dp[maxn*10];
LL prime[maxn],s=0;
bool vis[maxn];
void init_prime(){
    for(LL i=2;i<maxn;i++){
        if(!vis[i]){
            prime[s++]=i;
        }
        for(LL j=0;j<s&&i*prime[j]<maxn;j++){
            vis[i*prime[j]]=1;
            if(i%prime[j]==0){
                break;
            }
        }
    }
    return ;
}
LL pow_mod(LL a1,LL b1){
    LL ans=1;
    while(b1){
        if(b1&1){
            ans=ans*a1;
        }
        b1>>=1;
        a1*=a1;
    }
    return ans;
}
LL pow_mod2(LL a,LL b,LL p){
    LL ans=1;
    while(b){
        if(b&1){
            ans=ans*a%p;
        }
        b>>=1;
        a=a*a%p;
    }
    return ans;
}
LL gcd(LL a,LL b){
    return b?gcd(b,a%b):a;
}
bool f(LL n,LL p){
    if(pow_mod2(n,(p-1)>>1,p)!=1){
        return false;
    }
    return true;
}
struct matrix{
    LL x1,x2,x3,x4;
};
matrix matrix_a,matrix_b;
matrix M2(matrix aa,matrix bb,LL mod){
    matrix tmp;
    tmp.x1=(aa.x1*bb.x1%mod+aa.x2*bb.x3%mod)%mod;
    tmp.x2=(aa.x1*bb.x2%mod+aa.x2*bb.x4%mod)%mod;
    tmp.x3=(aa.x3*bb.x1%mod+aa.x4*bb.x3%mod)%mod;
    tmp.x4=(aa.x3*bb.x2%mod+aa.x4*bb.x4%mod)%mod;
    return tmp;
}
matrix M(LL n,LL mod){
    matrix a,b;
    a=matrix_a;b=matrix_b;
    while(n){
        if(n&1){
            b=M2(b,a,mod);
        }
        n>>=1;
        a=M2(a,a,mod);
    }
    return b;
}
/*bool g(matrix t){
    return t.m[0][0]==1&&t.m[0][1]==0&&t.m[1][0]==0&&t.m[1][1]==1;
}*/
LL fac[100][2],l,x,fs[1000];
void dfs(LL count,LL step){
    if(step==l){
        fs[x++]=count;
        return ;
    }
    LL sum=1;
    for(LL i=0;i<fac[step][1];i++){
        sum*=fac[step][0];
        dfs(count*sum,step+1);
    }
    dfs(count,step+1);
}
LL solve2(LL p){
    if(p<1e6&&dp[p]){
        return dp[p];
    }
    bool ok=f(5,p);//判断5是否为p的二次剩余 
    LL t;
    if(ok){
        t=p-1;
    }
    else{
        t=2*p+2;
    }
    l=0;
    for(LL i=0;i<s;i++){
        if(prime[i]>t/prime[i]){
            break;
        }
        if(t%prime[i]==0){
            LL count=0;
            fac[l][0]=prime[i];
            while(t%prime[i]==0){
                count++;t/=prime[i];
            }
            fac[l++][1]=count;
        }
    }
    if(t>1){
        fac[l][0]=t;
        fac[l++][1]=1;
    }
    x=0;
    dfs(1,0);//求t的因子 
    sort(fs,fs+x);
    for(LL i=0;i<x;i++){
        matrix m1=M(fs[i],p);
        if(m1.x1==m1.x4&&m1.x1==1&&m1.x2==m1.x3&&m1.x2==0){
            if(p<1e6){
                dp[p]=fs[i]; 
            }
            return fs[i];
        } 
    }
}
LL solve(LL n){
    LL ans=1,cnt;
    for(LL i=0;i<s;i++){
        if(prime[i]>n/prime[i]){
            break;
        }
        if(n%prime[i]==0){
            LL count=0;
            while(n%prime[i]==0){
                count++;n/=prime[i];
            }
            cnt=pow_mod(prime[i],count-1);
            cnt*=solve2(prime[i]);
            ans=(ans/gcd(ans,cnt))*cnt;
        }
    }
    if(n>1){
        cnt=1;
        cnt*=solve2(n);
        ans=ans/gcd(ans,cnt)*cnt;
    }
    return ans;
}
int main(){
    LL t,n;
    init_prime();
    matrix_a.x1=matrix_a.x2=matrix_a.x3=1;  
    matrix_a.x4=0;
    matrix_b.x1=matrix_b.x4=1;  
    matrix_b.x2=matrix_b.x3=0;
    dp[2]=3;dp[3]=8;dp[5]=20;
    scanf("%I64d",&t);
    while(t--){
        scanf("%I64d",&n);
        printf("%I64d\n",solve(n));
    }
    return 0;
}
```



## 分数规划

![image-20201016142309810](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201016142309810.png)

```cpp
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
using namespace std;

inline int read() {
  int X = 0, w = 1;
  char c = getchar();
  while (c < '0' || c > '9') {
    if (c == '-') w = -1;
    c = getchar();
  }
  while (c >= '0' && c <= '9') X = X * 10 + c - '0', c = getchar();
  return X * w;
}

const int N = 100000 + 10;
const double eps = 1e-6;

int n;
double a[N], b[N];

inline bool check(double mid) {
  double s = 0;
  for (int i = 1; i <= n; ++i)
    if (a[i] - mid * b[i] > 0)  // 如果权值大于 0
      s += a[i] - mid * b[i];   // 选这个物品
  return s > 0;
}

int main() {
  // 输入
  n = read();
  for (int i = 1; i <= n; ++i) a[i] = read();
  for (int i = 1; i <= n; ++i) b[i] = read();
  // 二分
  double L = 0, R = 1e9;
  while (R - L > eps) {
    double mid = (L + R) / 2;
    if (check(mid))  // mid 可行，答案比 mid 大
      L = mid;
    else  // mid 不可行，答案比 mid 小
      R = mid;
  }
  // 输出
  printf("%.6lf\n", L);
  return 0;
}
```

![image-20201016142350543](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20201016142350543.png)