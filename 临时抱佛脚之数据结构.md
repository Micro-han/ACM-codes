## 线段树动态开点+三元组置换+加法+乘法

```cpp
#include<bits/stdc++.h>
#define N 1100000
#define M 5500000
#define db double
#define ll long long 
#define ldb long double
#define ull unsigned long long
using namespace std;
const int h=3,ki=149,mo=1e9+7;
int mod(int x){return (x%mo+mo)%mo;}
int inc(int x,int k){x+=k;return x<mo?x:x-mo;}
int dec(int x,int k){x-=k;return x>=0?x:x+mo;}
int read(){int x;scanf("%d",&x);return x;}
void write(int x){printf("%d",x);}
struct node{int x,y,z;};
node operator+(node f,node g){return (node){inc(f.x,g.x),inc(f.y,g.y),inc(f.z,g.z)};}
node operator*(node f,int k){return {1ll*f.x*k%mo,1ll*f.y*k%mo,1ll*f.z*k%mo};}
node sp(node f,int k)
{
    k%=3;
    if(k==0)return (node){f.x,f.y,f.z};
    if(k==1)return (node){f.y,f.z,f.x};
    if(k==2)return (node){f.z,f.x,f.y};
}
struct Segment_Tree
{
    #define lson lc[o]
    #define rson rc[o]
    #define mid ((l+r)>>1)
    node f[M],addv[M];
    int size=0,lc[M],rc[M],mulv[M],revv[M];
    void insert(int &o){if(!o)o=++size,mulv[o]=1;}
    int pushup(int o){f[o]=f[lson]+f[rson];}
    void mul(int o,int k)
    {
        f[o]=f[o]*k;
        addv[o]=addv[o]*k;
        mulv[o]=1ll*mulv[o]*k%mo;
    }
    void rev(int o,int k)
    {
        f[o]=sp(f[o],k);
        addv[o]=sp(addv[o],k);
        revv[o]=(revv[o]+k)%3;
    }
    void add(int o,int l,int r,node k)
    {
        f[o]=f[o]+(k*(r-l+1));
        addv[o]=addv[o]+k;
    }
    void pushdown(int o,int l,int r)
    {
        insert(lson);mul(lson,mulv[o]);rev(lson,revv[o]);add(lson,l,mid,addv[o]);
        insert(rson);mul(rson,mulv[o]);rev(rson,revv[o]);add(rson,mid+1,r,addv[o]);
        mulv[o]=1;revv[o]=0;addv[o]=(node){0,0,0};
    }
    void optmul(int &o,int l,int r,int ql,int qr,int k)
    {
        insert(o);
        if(ql<=l&&r<=qr)return mul(o,k);
        pushdown(o,l,r);
        if(ql<=mid)optmul(lson,l,mid,ql,qr,k);
        if(qr>mid)optmul(rson,mid+1,r,ql,qr,k);
        pushup(o);
    }
    void optrev(int &o,int l,int r,int ql,int qr,int k)
    {
        insert(o);
        if(ql<=l&&r<=qr)return rev(o,k);
        pushdown(o,l,r);
        if(ql<=mid)optrev(lson,l,mid,ql,qr,k);
        if(qr>mid)optrev(rson,mid+1,r,ql,qr,k);
        pushup(o);
    }   
    void optadd(int &o,int l,int r,int ql,int qr,node k)
    {
        insert(o);
        if(ql<=l&&r<=qr)return add(o,l,r,k);
        pushdown(o,l,r);
        if(ql<=mid)optadd(lson,l,mid,ql,qr,k);
        if(qr>mid)optadd(rson,mid+1,r,ql,qr,k);
        pushup(o);
    }
    node query(int o,int l,int r,int ql,int qr)
    {
        if(!o)return (node){0,0,0};
        if(ql<=l&&r<=qr)return f[o];
        pushdown(o,l,r);
        node ans=(node){0,0,0};
        if(ql<=mid)ans=ans+query(lson,l,mid,ql,qr);
        if(qr>mid)ans=ans+query(rson,mid+1,r,ql,qr);
        return ans;
    }
}T;
int main()
{
    int n=read(),qnum=read(),rt=0;
    for(int i=1;i<=qnum;i++)
    {
        int flag=read(),l=read(),r=read();
        if(flag==1)
        {
            node k;
            k.x=read();k.y=read();k.z=read();
            T.optadd(rt,1,n,l,r,k);
        }
        if(flag==2)
        {
            int k;
            k=read();
            T.optmul(rt,1,n,l,r,k);
        }
        if(flag==3)
        {
            T.optrev(rt,1,n,l,r,1);
        }
        if(flag==4)
        {
            node ans=T.query(rt,1,n,l,r);
            int res=0;
            res=inc(res,1ll*ans.x*ans.x%mo);
            res=inc(res,1ll*ans.y*ans.y%mo);
            res=inc(res,1ll*ans.z*ans.z%mo);
            printf("%d\n",res);
        }
    }
    return 0;
}
```

## 线段树+哈希

对于区间[X,Y]每个数+1并对65536取模，判断区间[X,X+L-1],[Y,Y+L-1]是否完全相同

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
#include<queue>
#include<map>
#include<stack>
#include<set>
#define iss ios::sync_with_stdio(false)
using namespace std;
typedef long long ll;
const int mod = 65536;
const int mod1 = 1e9 + 7;
const int mod2 = 998244353;
const int r = 31;
const int maxn = 2e6 + 7;
ll Hash[maxn],ma[maxn],la[maxn];
ll pre[maxn],poww[maxn];   // base 的幂次     前缀和
int a[maxn] ,n,q,x,y,op,L;
void pushup(int l , int r, int rt){
    int mid = (l + r) / 2;
    Hash[rt] = (Hash[rt << 1] * poww[r - mid] % mod1 + Hash[rt << 1 | 1]) % mod1;
    ma[rt] = max(ma[rt << 1] , ma[rt << 1 | 1]);
}
void pushdown(int l,int r,int rt){
    if(la[rt] == 0) return ;
    int  mid = (l + r) / 2;
    
    Hash[rt << 1] = (Hash[rt << 1] + la[rt] *  pre[mid - l] % mod1) % mod1;     //加上前缀和的 幂次
    Hash[rt << 1 | 1] = (Hash[rt << 1 | 1] + la[rt] * pre[r - mid - 1] % mod1) % mod1;

    ma[rt << 1] += la[rt];
    ma[rt << 1|1] += la[rt];


    la[rt<<1] += la[rt];
    la[rt<<1|1] += la[rt];
    la[rt] = 0;
}
void update(int L,int R,int l,int r,int rt){
    if(L <= l && R >= r){
        Hash[rt] = (Hash[rt] + pre[r - l]) % mod1;
        la[rt] ++;
        ma[rt] ++;
        return ;
	}
	pushdown(l , r, rt);
	int mid = (l + r) / 2;
	if(R > mid) update(L , R ,mid + 1 ,r ,rt << 1 | 1);
	if(L <= mid) update(L ,R ,l , mid , rt << 1);
	pushup(l ,r , rt);
}
void update_mod(int l,int r,int rt){  //考虑溢出
    if(ma[rt] < mod){                 //没有超过 mod的 直接退出
        return ;
    }
    if(l == r){
        ma[rt] -= mod;
        Hash[rt] -= mod;
        return ;
    }
    pushdown(l , r, rt);
    int mid = (l + r) / 2;
    if(ma[rt << 1] >= mod) update_mod( l , mid ,rt << 1);
    if(ma[rt << 1 | 1] >= mod) update_mod(mid + 1 , r, rt << 1 | 1);
    pushup(l , r, rt);

}
ll query(int L,int R,int l,int r,int rt){
	ll s = 0;
	if(L <= l && R >= r){
        return Hash[rt];
	}
	pushdown(l , r, rt);
	int mid = (l + r) / 2;
	if(R > mid)  s = (s + query(L,R,mid + 1,r,rt<<1|1) ) % mod1;
	if(L <= mid) s = (s + poww[max(0,min(R , r)- mid)] * query(L,R,l,mid,rt<<1) % mod1) % mod1;
	return s;
}
void build(int l,int r ,int rt){
    if(l == r){
        Hash[rt] = a[l];
        ma[rt] = a[l];
        return ;
    }
    int mid = (l + r) / 2;
    build(l , mid ,rt << 1);
    build(mid + 1 , r,rt << 1 | 1);
    pushup(l,r, rt);
}
int main (){
    poww[0] = pre[0] = 1;
    for(int i = 1; i <= 5e5 ; i ++){
        poww[i] = poww[i-1] * r % mod1;
    }
    for(int i = 1; i <= 5e5 ; i ++){
     pre[i] =  (pre[i-1] + poww[i]) % mod1;
    }
    scanf("%d%d",&n,&q);
    for(int i = 1; i<= n; i ++){
        scanf("%d",&a[i]);
    }
    build(1 , n,1);
    while(q--){
        scanf("%d",&op);
        if(op == 1){
            scanf("%d%d",&x,&y);
            update(x,y,1,n,1);
            update_mod(1 , n , 1);
        }
        if(op == 2){
            scanf("%d%d%d",&x,&y,&L);
            ll h1 = query(x , x + L - 1 ,1 , n, 1);
            ll h2 = query(y , y + L - 1 ,1 , n, 1);
            if(h1 == h2 ) printf ("yes\n");
            else printf ("no\n");
        }
    }
}
```

## 线段树+差分

给出两个序列a和b，生成方式为 c0=0,ci=max(bi+c_{i-1},ai)

```c++
// % everyone
#include <cstdio>
#include<iostream>
#include<cstring>
#include <map>
#include <queue>
#include <set>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <vector>
#include <string>
#include <list>
#include <cctype>
#include <time.h>

namespace IO {
    double start_time = 0.0;
    void ct() { start_time = clock(); return; }
    void fast_cin() { std::ios::sync_with_stdio(false); std::cin.tie(); }
    void read_f(int flag = 0) { freopen("0.in", "r", stdin); if(!flag) freopen("0.out", "w", stdout); }
    void run_time() { std::cout << "\nESC in : " << ( clock() - start_time ) * 1000.0 / CLOCKS_PER_SEC << "ms" << std::endl; }
}
using namespace IO;
template <typename T>
bool bacmp(const T & a, const T & b) { return a > b; }
template <typename T>
bool pecmp(const T & a, const T & b) { return a < b; }

#define ll long long
#define ull unsigned ll
#define _min(x, y) ((x)>(y)?(y):(x))
#define _max(x, y) ((x)>(y)?(x):(y))
#define max3(x, y, z) ( max( (x), max( (y), (z) ) ) )
#define min3(x, y, z) ( min( (x), min( (y), (z) ) ) )
#define pr make_pair
#define pb push_back
#define int ll
using namespace std;

const int N = 2e5+6;
const int mod = 1e9+7;
const int inf = 0x3f3f3f3f;
ll a[N], b[N], b0[N];
struct Node
{
    int l, r;
    ll a, b, dif;
    ll laz;
}tr[N<<2];
void update(int p, int v)
{
    tr[p].laz += v;
    tr[p].b += v;
    tr[p].dif -= v;
}
void spread(int p)
{
    if (tr[p].laz == 0) return;
    update(p<<1, tr[p].laz);
    update(p<<1|1, tr[p].laz);
    tr[p].laz = 0;
}
void pushup(int p)
{
    tr[p].dif = max(tr[p<<1].dif, tr[p<<1|1].dif);
}
void build(int p, int l, int r)
{
    tr[p].l = l; tr[p].r = r;
    tr[p].laz = 0;
    if (l == r)
    {
        tr[p].a = a[l];
        tr[p].b = b[l];
        tr[p].dif = a[l] - b[l];
        return;
    }
    int mid = (l + r) >> 1;
    build(p<<1, l, mid);
    build(p<<1|1, mid+1, r);
    pushup(p);
}
void changeb(int p, int l, int r, int v)
{
    if (l <= tr[p].l && tr[p].r <= r)
    {
        update(p, v); return;
    }
    spread(p);
    int mid = (tr[p].l + tr[p].r) >> 1;
    if (l <= mid) changeb(p<<1, l, r, v);
    if (r > mid) changeb(p<<1|1, l, r, v);
    pushup(p);
}
void changea(int p, int pos, int v)
{
    if (tr[p].l == tr[p].r)
    {
        tr[p].a += v;
        tr[p].dif += v;
        return;
    }
    spread(p);
    int mid = (tr[p].l + tr[p].r) >> 1;
    if (pos <= mid) changea(p<<1, pos, v);
    else changea(p<<1|1, pos, v);
    pushup(p);
}
ll askb(int p, int x)
{
    if (tr[p].l == tr[p].r)
        return tr[p].b;
    int mid = (tr[p].l + tr[p].r) >> 1;
    spread(p);
    if (x <= mid) return askb(p<<1, x);
    else return askb(p<<1|1, x);
}
ll askdif(int p, int l, int r)
{
    if (l <= tr[p].l && tr[p].r <= r)
        return tr[p].dif;
    int mid = (tr[p].l + tr[p].r) >> 1;
    spread(p);
    ll val = -1ll * inf * inf;
    if (l <= mid) val = askdif(p<<1, l, r);
    if (r > mid) val = max(val, askdif(p<<1|1, l, r));
    return val;
}

signed main()
{
    int n, m;
    while(~scanf("%lld%lld", &n, &m))
    {
        for (int i = 1; i <= n; i++)
            scanf("%lld", &a[i]);
        for (int i = 1; i <= n; i++)
            scanf("%lld", &b[i]), b0[i] = b[i], b[i] +=b[i-1];
        build(1, 1, n);
        while(m--)
        {
            int op, x, y;
            scanf("%lld%lld", &op, &x);
            if (op == 3)
            {
                ll g = askb(1, x);
                ll dif = max(0ll, askdif(1, 1, x));
                printf("%lld\n", g+dif);
            }
            else if (op == 1)
            {
                scanf("%lld", &y);
                changea(1, x, y - a[x]);
                a[x] = y;
            }
            else
            {
                scanf("%lld", &y);
                changeb(1, x, n, y - b0[x]);
                b0[x] = y;
            }
        }
    }
    return 0;
}
```

## 吉老师线段树

0 l r区间大于x的数变成x

1 l r区间最大值

2 l r区间和

```c++
#include<stdio.h>
#include<algorithm>
using namespace std;
const int maxn = 1e6+2;
int a[maxn];
typedef long long ll;
struct Node
{
	int max,max2,tag,l,r,num;
	ll sum;
}node[maxn<<2];
void up(int no)
{
	node[no].sum = node[no<<1].sum + node[no<<1|1].sum;
	if(node[no<<1].max == node[no<<1|1].max)
	{
		node[no].max = node[no<<1].max;
		node[no].num = node[no<<1].num + node[no<<1|1].num;
		node[no].max2 = max(node[no<<1].max2,node[no<<1|1].max2);
	}
	else
	{
		node[no].max = max(node[no<<1].max,node[no<<1|1].max);
		node[no].max2 = max(node[no<<1].max2,max(node[no<<1|1].max2,min(node[no<<1].max,node[no<<1|1].max)));
		node[no].num = (node[no<<1].max > node[no<<1|1].max ? node[no<<1].num : node[no<<1|1].num);
	}
}

void build(int l,int r,int no)
{
	node[no].l = l;
	node[no].r = r;
	node[no].tag = -1;
	if(l == r)
	{
		node[no].num = 1;
		node[no].max = a[l];
		node[no].max2 = -1;
		node[no].sum = a[l];
		return;
	}
	int mid = l + r >> 1;
	build(l,mid,no<<1);
	build(mid+1,r,no<<1|1);
	up(no);
}
void change(int no,int num)
{
	if(num >= node[no].max) return;
	if(num > node[no].max2)
	{
		node[no].sum -= 1ll * node[no].num * (node[no].max- num);
		node[no].max = num;
		node[no].tag = num;
		return;
	}
}
void down(int no)
{
	change(no<<1,node[no].tag);
	change(no<<1|1,node[no].tag);
	node[no].tag = -1;
}

void update(int l,int r,int num,int no)
{
	if(node[no].l >= l && node[no].r <= r)
	{
		if(num >= node[no].max) return;
		if(num > node[no].max2)
		{
			node[no].sum -= 1ll * node[no].num * (node[no].max - num);
			node[no].max = num;
			node[no].tag = num;
			return;
		}
		int mid = node[no].l + node[no].r >> 1;
		update(node[no].l,mid,num,no<<1);
		update(mid + 1,node[no].r,num,no<<1|1);
		up(no);
		return;
	}
	if(node[no].tag != -1)
		down(no);
	int mid = node[no].l + node[no].r >> 1;
	if(l <= mid)
		update(l,r,num,no<<1);
	if(r > mid)
		update(l,r,num,no<<1|1);
	up(no);
}
int query1(int l,int r,int no)
{
	if(node[no].l > r || node[no].r < l)
		return -1;
	if(node[no].l >= l && node[no].r <= r)
		return node[no].max;
	if(node[no].tag != -1)
		down(no);
	return max(query1(l,r,no<<1),query1(l,r,no<<1|1));
}

ll query2(int l,int r,int no)
{
	if(node[no].l > r || node[no].r < l)
		return 0;
	if(node[no].l >= l && node[no].r <= r)
		return node[no].sum;
	if(node[no].tag != -1)
		down(no);
	return query2(l,r,no<<1) + query2(l,r,no<<1|1);
}
//void init(int n)
//{
//	for (int no = 1; no <= (n << 2); no ++ )
//	{
//		node[no].l = node[no].r = node[no].max = node[no].max2 = node[no].num = node[no].sum = node[no].tag = 0;
//	}
//}

int main()
{
	int T;
	scanf("%d",&T);
	while(T -- )
	{
		int n,m;
		scanf("%d%d",&n,&m);
//		init(n);
		for (int i = 1; i <= n; i ++ )
		{
			scanf("%d",&a[i]);
		}
		build(1,n,1);
		while(m -- )
		{
			int f ;
			scanf("%d",&f);
			if(f == 0)
			{
				int l,r,num;
				scanf("%d%d%d",&l,&r,&num);
				update(l,r,num,1);
			}
			else if(f == 1)
			{
				int l,r;
				scanf("%d%d",&l,&r);
				int ans = query1(l,r,1);
				printf("%d\n",ans);
			}
			else if(f == 2)
			{
				int l,r;
				scanf("%d%d",&l,&r);
				ll ans = query2(l,r,1);
				printf("%lld\n",ans);
			}
		}
	}
 } 
```

## 线段树区间最大子段和

```c++
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <math.h>
#include <algorithm>
#include <map>
#include <vector>
#include <queue>
#include <stack>
#include <set>
#include <bitset>
#include <time.h>
using namespace std;
//AcWing

typedef long long ll;
typedef unsigned long long ull;
const int N = 5e5 +10;
const ll mod = 1e9 + 7;
const ll inf = 1e18;
const double eps = 1e-8;
const int maxn = 8e7+10;
const int INF = 1e9+7;
const double mpi=3.1415926535;
inline int read() {
    int f=1,x=0;char ch;
    do {ch=getchar(); if(ch=='-') f=-1;} while (ch<'0'||ch>'9');
    do {x=x*10+ch-'0'; ch=getchar(); } while (ch>='0'&&ch<='9');
    return x*f;
}

void redirect() {
    #ifdef LOCAL
        freopen("in.txt","r",stdin);
        freopen("out.txt","w",stdout);
    #endif
}
struct arr{
    int lmx,rmx,sum,num;//lmx前缀 rmx后缀 
}s[N*4],nul;
int a[N];
int n,q;
arr pushup(arr a,arr b){    
    arr t;
    t.sum=a.sum+b.sum;
    t.lmx=max(a.sum+b.lmx,a.lmx);
    t.rmx=max(b.sum+a.rmx,b.rmx);
    t.num=max(a.num,max(b.num,a.rmx+b.lmx));
    return t;
}
void build(int node,int l,int r){
    int mid=(l+r)>>1;
    if(l==r){
        s[node].sum=a[l];
        s[node].lmx=a[l];
        s[node].rmx=a[l];
        s[node].num=a[l];
        return;
    }
    build(node<<1,l,mid);
    build(node<<1|1,mid+1,r);
    s[node]=pushup(s[node<<1],s[node<<1|1]);
}
arr query(int L,int R,int l,int r,int node){
    //if(L>R)return nul;
    int mid=(l+r)>>1;
    if(L<=l && r<=R)return s[node];
    if(R<=mid)return query(L,R,l,mid,node<<1);
    if(L>mid)return query(L,R,mid+1,r,node<<1|1);
    return pushup(query(L,R,l,mid,node<<1),query(L,R,mid+1,r,node<<1|1));
}
void update(int L,int X,int l,int r,int node){
    if(l==r){
        s[node].lmx=X;
        s[node].rmx=X;
        s[node].sum=X;
        s[node].num=X;
        return ;
    }
    int mid=(l+r)/2;
    if(L<=mid)update(L,X,l,mid,node<<1);
    else update(L,X,mid+1,r,node<<1|1);
    s[node]=pushup(s[node<<1],s[node<<1|1]);
}
int main(){
    int T=1;
    //scanf("%d",&T);
    while(T--){
        scanf("%d%d",&n,&q);
        for(int i=1;i<=n;i++)scanf("%d",&a[i]);
        build(1,1,n);
        while(q--){
            int opt;
            scanf("%d",&opt);
            if(opt==1){
                int l,r;
                scanf("%d%d",&l,&r);
                if(l>r)swap(l,r);
                printf("%d\n",query(l,r,1,n,1).num);
            } else {
                int l,r;
                scanf("%d%d",&l,&r);
                update(l,r,1,n,1);
            }
        }
    }
    return 0;
}
/*相同只算一次
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long LL;
inline LL read(){
    LL x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}
    return x*f;
}
const int MAXN=100005;
struct Node{
    LL sum,hix,stag,htag;
    Node(){
        sum=hix=stag=htag=0;
    }
    friend Node operator + (Node lf,Node rt){
        Node res;
        res.sum=max(lf.sum,rt.sum);
        res.hix=max(lf.hix,rt.hix);
        return res;
    }
}b[MAXN*4];
struct Qst{
    int l,r,id;
}q[MAXN];
bool cmp(Qst x,Qst y){
    return x.r<y.r;
}
int n,m,cur[MAXN*2],pre[MAXN],ql,qr;LL a[MAXN],ans[MAXN],k;
#define mid ((l+r)>>1)
#define lc (o<<1)
#define rc ((o<<1)|1)
void pushup(int o){
    b[o]=b[lc]+b[rc];
}
void pushdown(int o){//注意更新先后顺序 
    b[lc].hix=max(b[lc].hix,b[lc].sum+b[o].htag);
    b[rc].hix=max(b[rc].hix,b[rc].sum+b[o].htag);
    b[lc].sum+=b[o].stag;
    b[rc].sum+=b[o].stag;
    b[lc].htag=max(b[lc].htag,b[lc].stag+b[o].htag);
    b[rc].htag=max(b[rc].htag,b[rc].stag+b[o].htag);
    b[lc].stag+=b[o].stag;
    b[rc].stag+=b[o].stag;
    b[o].stag=b[o].htag=0;
}
void upd(int o,int l,int r){
    if(ql<=l&&r<=qr){
        b[o].sum+=k;
        b[o].hix=max(b[o].hix,b[o].sum);
        b[o].stag+=k;
        b[o].htag=max(b[o].htag,b[o].stag);
        return;
    }
    pushdown(o);
    if(mid>=ql) upd(lc,l,mid);
    if(mid<qr) upd(rc,mid+1,r);
    pushup(o);
}
Node query(int o,int l,int r){
    if(ql<=l&&r<=qr) return b[o];
    pushdown(o);
    if(mid<ql) return query(rc,mid+1,r);
    else if(mid>=qr) return query(lc,l,mid);
    else return query(lc,l,mid)+query(rc,mid+1,r);
}
int main(){
    n=read();
    for(int i=1;i<=n;i++){
        a[i]=read();
        pre[i]=cur[a[i]+(int)1e5];
        cur[a[i]+(int)1e5]=i;
    }
    m=read();
    for(int i=1;i<=m;i++){
        q[i].l=read(),q[i].r=read();
        q[i].id=i;
    }
    sort(q+1,q+m+1,cmp);
    int j=1;
    for(int i=1;i<=n;i++){
        ql=pre[i]+1,qr=i,k=a[i];
        upd(1,1,n);
        for(;j<=m&&q[j].r<=i;j++){
            ql=q[j].l,qr=q[j].r;
            ans[q[j].id]=query(1,1,n).hix;
        }
    }
    for(int i=1;i<=m;i++)
        printf("%lld\n",ans[i]);
    return 0;
}
*/
/*左端点再[x1,y1] 右端点再[x2,y2]的最大子段和
#include<cstdio>

inline int read(){
	int r=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')r=(r<<1)+(r<<3)+c-'0',c=getchar();
	return r*f;
}

struct TR{//ll指的是区间最大前缀和，rr指的是区间最大后缀和
	int l,r,max,min,ll,rr,sum,max_sum;//sum是区间和，max_sum是最大子段和
}tr[400004];

int a[100001],n,m,r_s[100001];

inline int max(int a,int b){
	return a>b?a:b;
}

inline int min(int a,int b){
	return a<b?a:b;
}

void build(int p,int l,int r){
	tr[p].l=l,tr[p].r=r;
	if(l==r){
		tr[p].max=r_s[l]+a[l];
		tr[p].min=r_s[l];
		tr[p].max_sum=tr[p].sum=tr[p].ll=tr[p].rr=a[l];
		return;
	}
	int mid=l+r>>1;
	build(p*2,l,mid);
	build(p*2+1,mid+1,r);
	if(tr[p*2].max>tr[p*2+1].max)tr[p].ll=tr[p*2].ll;
	else tr[p].ll=tr[p*2+1].ll;
	tr[p].max=max(tr[p*2].max,tr[p*2+1].max);
	tr[p].min=min(tr[p*2].min,tr[p*2+1].min);
	tr[p].max_sum=max(tr[p*2].rr+tr[p*2+1].ll,max(tr[p*2].max_sum,tr[p*2+1].max_sum));//更新方式多样
	tr[p].sum=tr[p*2].sum+tr[p*2+1].sum;
	tr[p].ll=max(tr[p*2].ll,tr[p*2].sum+tr[p*2+1].ll);
	tr[p].rr=max(tr[p*2+1].rr,tr[p*2+1].sum+tr[p*2].rr);
}

int query_max(int p,int l,int r){
	if(l<=tr[p].l&&tr[p].r<=r)return tr[p].max;
	int mid=tr[p].l+tr[p].r>>1;
	if(l>mid)return query_max(p*2+1,l,r);
	if(r<=mid)return query_max(p*2,l,r);
	return max(query_max(p*2,l,r),query_max(p*2+1,l,r));
}

int query_min(int p,int l,int r){
	if(l<=tr[p].l&&tr[p].r<=r)return tr[p].min;
	int mid=tr[p].l+tr[p].r>>1;
	if(l>mid)return query_min(p*2+1,l,r);
	if(r<=mid)return query_min(p*2,l,r);
	return min(query_min(p*2,l,r),query_min(p*2+1,l,r));
}

inline TR mer_TR(TR a,TR b){
	TR maxx;
	maxx.max_sum=max(a.rr+b.ll,max(a.max_sum,b.max_sum));
	maxx.sum=a.sum+b.sum;
	maxx.ll=max(a.ll,a.sum+b.ll);
	maxx.rr=max(b.rr,b.sum+a.rr);
	return maxx;
}

TR query(int p,int l,int r){
	if(l<=tr[p].l&&tr[p].r<=r)return tr[p];
	int mid=tr[p].l+tr[p].r>>1;
	TR max_sum;
	if(l>mid)return query(p*2+1,l,r);
	if(r<=mid)return query(p*2,l,r);
	return mer_TR(query(p*2,l,r),query(p*2+1,l,r));//合并两个区间
}

inline int max_ans(int l1,int r1,int l2,int r2){
	int x=query(1,l2,r1).max_sum;//相交部分最大子段和
	int y=query_max(1,l1,l2)-query_min(1,l2,r2);//左段与右边整个区间
	int z=query_max(1,l1,r1)-query_min(1,r1,r2);//右段与左边整个区间
	return max(x,max(y,z));//取大
}

int main(){
	int t=read();
	for(int i=1;i<=t;i++){
		n=read();
		for(int i=1;i<=n;i++)a[i]=read();
		for(int i=n-1;i>=1;i--)r_s[i]=r_s[i+1]+a[i+1];
		build(1,1,n);
		m=read();
		for(int i=1;i<=m;i++){
			int l=read(),r=read(),ll=read(),rr=read();
			if(r<=ll)printf("%d\n",query_max(1,l,r)-query_min(1,ll,rr));//不相交
			else printf("%d\n",max_ans(l,r,ll,rr));//相交
		}
	}
	return 0;
}
*/
```

## 线段树区间最大公约数

```c++
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <math.h>
#include <algorithm>
#include <map>
#include <vector>
#include <queue>
#include <stack>
#include <set>
#include <bitset>
#include <time.h>

using namespace std;
//AcWing

typedef long long ll;
typedef unsigned long long ull;
const int N = 5e5 + 10;
const ll mod = 1e9 + 7;
const ll inf = 1e18;
const double eps = 1e-8;
const int maxn = 8e7+10;
const int INF = 1e9+7;
const double mpi=3.1415926535;
inline int read() {
    int f=1,x=0;char ch;
    do {ch=getchar(); if(ch=='-') f=-1;} while (ch<'0'||ch>'9');
    do {x=x*10+ch-'0'; ch=getchar(); } while (ch>='0'&&ch<='9');
    return x*f;
}

void redirect() {
    #ifdef LOCAL
        freopen("in.txt","r",stdin);
        freopen("out.txt","w",stdout);
    #endif
}

int n,m;
ll a[N];
struct arr{
    ll d,sum;
}tr[N*4];
char opt[4];
ll gcd(ll a,ll b){
    return b? gcd (b,a%b):a;
}
void pushup(int rt){
    tr[rt].d=gcd(tr[rt<<1].d,tr[rt<<1|1].d);
    tr[rt].sum=tr[rt<<1].sum+tr[rt<<1|1].sum;
}
void build(int rt,int l,int r){
    if(l==r){
        tr[rt].d=a[l]-a[l-1];
        tr[rt].sum=a[l]-a[l-1];
        return;
    }
    int mid=(l+r)>>1;
    build(rt<<1,l,mid);
    build(rt<<1|1,mid+1,r);
    pushup(rt);
}
void change(int L,ll X,int l,int r,int rt){
    if(l==r){
        tr[rt].sum+=X;
        tr[rt].d+=X;
        return;
    }
    int mid=(l+r)>>1;
    if(L<=mid)change(L,X,l,mid,rt<<1);
    else change(L,X,mid+1,r,rt<<1|1);
    pushup(rt);
}
ll query1(int L,int R,int l,int r,int rt){
    if(L<=l && r<=R)return tr[rt].d;
    int mid=(l+r)>>1;
    ll res=0;
    if(L<=mid)res=gcd(res,query1(L,R,l,mid,rt<<1));
    if(R>mid)res=gcd(res,query1(L,R,mid+1,r,rt<<1|1));
    pushup(rt);
    return res;
}
ll query2(int L,int R,int l,int r,int rt){
    if(L<=l && r<=R)return tr[rt].sum;
    int mid=(l+r)>>1;
    ll res=0;
    if(L<=mid)res+=query2(L,R,l,mid,rt<<1);
    if(R>mid)res+=query2(L,R,mid+1,r,rt<<1|1);
    pushup(rt);
    return res;
}
int main(){
    redirect();

    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
    build(1,1,n);
    while(m--){
        scanf("%s",opt);
        if(opt[0]=='Q'){
            int l,r;
            scanf("%d%d",&l,&r);
            if(l+1<=r)printf("%lld\n",abs(gcd(query2(1,l,1,n,1),query1(l+1,r,1,n,1))));
            else printf("%lld\n",abs(query2(1,l,1,n,1)));
        } else {
            int l,r;ll d;
            scanf("%d%d%lld",&l,&r,&d);
            change(l,d,1,n,1);
            if(r<n)change(r+1,-d,1,n,1);
        }
    }
    return 0;
}
```

## 扫描线

```cpp
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <math.h>
#include <algorithm>
#include <map>
#include <vector>
#include <queue>
#include <stack>
#include <set>
#include <bitset>
#include <time.h>
using namespace std;
//AcWing

typedef long long ll;
typedef unsigned long long ull;
const int N = 1e5 + 10;
const ll mod = 1e9 + 7;
const ll inf = 1e18;
const double eps = 1e-8;
const int maxn = 8e7+10;
const int INF = 1e9+7;
const double mpi=3.1415926535;
inline int read() {
    int f=1,x=0;char ch;
    do {ch=getchar(); if(ch=='-') f=-1;} while (ch<'0'||ch>'9');
    do {x=x*10+ch-'0'; ch=getchar(); } while (ch>='0'&&ch<='9');
    return x*f;
}

void redirect() {
    #ifdef LOCAL
        freopen("in.txt","r",stdin);
        freopen("out.txt","w",stdout);
    #endif
}

struct Segment{
    double x,upy,downy;
    int io;
}seg[N*4];
struct Node{
    int l,r;
    int cnt;
    double len;
}tr[N*4];
vector<double>ys;
int n;
bool cmp(Segment x,Segment y){
    return x.x<y.x;
}
int find(double y){
    return lower_bound(ys.begin(),ys.end(),y)-ys.begin();
}
void pushup(int rt){
    if(tr[rt].cnt)tr[rt].len=ys[tr[rt].r+1]-ys[tr[rt].l];
    else if(tr[rt].l!=tr[rt].r){
        tr[rt].len=tr[rt<<1].len+tr[rt<<1|1].len;
    } else tr[rt].len = 0;
}
void build(int rt,int l,int r){
    tr[rt]={l,r,0,0};
    if(l!=r){
        int mid=(l+r)>>1;
        build(rt<<1,l,mid);
        build(rt<<1|1,mid+1,r);
    }
}
void modify(int rt,int l,int r,int k){
    if(tr[rt].l>=l && tr[rt].r<=r){
        tr[rt].cnt+=k;
        pushup(rt);
    } else {
        int mid=(tr[rt].l+tr[rt].r)>>1;
        if(l<=mid)modify(rt<<1,l,r,k);
        if(r>mid)modify(rt<<1|1,l,r,k);
        pushup(rt);
    }
}
int main(){
    redirect();

    int T=0;
    while(~scanf("%d",&n)){
        if(n==0)break;
        ys.clear();
        for(int i=0,j=0;i<n;i++){
            double x,y,z,w;
            scanf("%lf%lf%lf%lf",&x,&y,&z,&w);
            seg[j++]={x,y,w,1};
            seg[j++]={z,y,w,-1};
            ys.push_back(y),ys.push_back(w);
        }
        sort(ys.begin(),ys.end());
        ys.erase(unique(ys.begin(),ys.end()),ys.end());
        build(1,0,ys.size()-2);
        sort(seg,seg+n*2,cmp);
        double ans=0;
        for(int i=0;i<n*2;i++){
            if(i>0)ans+=tr[1].len*(seg[i].x-seg[i-1].x);
            modify(1,find(seg[i].upy),find(seg[i].downy)-1,seg[i].io);
        }

        printf("Test case #%d\n",++T);
        printf("Total explored area: %.2lf\n\n",ans);
    }

    return 0;
}
```

## 最大异或和

序列末尾添加一个数x 使得序列长度加1

询问区间L，R之内a[p] xor a[p+1] xor ... a[N] xor x最大

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 600010, M = N * 25;

int n, m;
int s[N];
int tr[M][2], max_id[M];
int root[N], idx;

void insert(int i, int k, int p, int q)
{
    if (k < 0)
    {
        max_id[q] = i;
        return;
    }
    int v = s[i] >> k & 1;
    if (p) tr[q][v ^ 1] = tr[p][v ^ 1];
    tr[q][v] = ++ idx;
    insert(i, k - 1, tr[p][v], tr[q][v]);
    max_id[q] = max(max_id[tr[q][0]], max_id[tr[q][1]]);
}

int query(int root, int C, int L)
{
    int p = root;
    for (int i = 23; i >= 0; i -- )
    {
        int v = C >> i & 1;
        if (max_id[tr[p][v ^ 1]] >= L) p = tr[p][v ^ 1];
        else p = tr[p][v];
    }

    return C ^ s[max_id[p]];
}

int main()
{
    scanf("%d%d", &n, &m);

    max_id[0] = -1;
    root[0] = ++ idx;
    insert(0, 23, 0, root[0]);

    for (int i = 1; i <= n; i ++ )
    {
        int x;
        scanf("%d", &x);
        s[i] = s[i - 1] ^ x;
        root[i] = ++ idx;
        insert(i, 23, root[i - 1], root[i]);
    }

    char op[2];
    int l, r, x;
    while (m -- )
    {
        scanf("%s", op);
        if (*op == 'A')
        {
            scanf("%d", &x);
            n ++ ;
            s[n] = s[n - 1] ^ x;
            root[n] = ++ idx;
            insert(n, 23, root[n - 1], root[n]);
        }
        else
        {
            scanf("%d%d%d", &l, &r, &x);
            printf("%d\n", query(root[r - 1], s[n] ^ x, l - 1));
        }
    }

    return 0;
}
```

## AC自动机

给定n个单词和一篇长为m的文章 问有多少个单词在文章中出现过

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 10010, S = 55, M = 1000010;

int n;
int tr[N * S][26], cnt[N * S], idx;
char str[M];
int q[N * S], ne[N * S];

void insert()
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int t = str[i] - 'a';
        if (!tr[p][t]) tr[p][t] = ++ idx;
        p = tr[p][t];
    }
    cnt[p] ++ ;
}

void build()
{
    int hh = 0, tt = -1;
    for (int i = 0; i < 26; i ++ )
        if (tr[0][i])
            q[ ++ tt] = tr[0][i];

    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = 0; i < 26; i ++ )
        {
            int p = tr[t][i];
            if (!p) tr[t][i] = tr[ne[t]][i];
            else
            {
                ne[p] = tr[ne[t]][i];
                q[ ++ tt] = p;
            }
        }
    }
}

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        memset(tr, 0, sizeof tr);
        memset(cnt, 0, sizeof cnt);
        memset(ne, 0, sizeof ne);
        idx = 0;

        scanf("%d", &n);
        for (int i = 0; i < n; i ++ )
        {
            scanf("%s", str);
            insert();
        }

        build();

        scanf("%s", str);

        int res = 0;
        for (int i = 0, j = 0; str[i]; i ++ )
        {
            int t = str[i] - 'a';
            j = tr[j][t];

            int p = j;
            while (p)
            {
                res += cnt[p];
                cnt[p] = 0;
                p = ne[p];
            }
        }

        printf("%d\n", res);
    }

    return 0;
}
```

## 权值并查集

![image-20210414085354234](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20210414085354234.png)

```c++
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <math.h>
#include <algorithm>
#include <map>
#include <vector>
#include <queue>
#include <stack>
#include <set>
#include <bitset>
#include <time.h>
using namespace std;
//AcWing

typedef long long ll;
typedef unsigned long long ull;
const int N = 1e6 +10;
const ll mod = 1e9 + 7;
const ll inf = 1e18;
const double eps = 1e-8;
const int maxn = 8e7+10;
const int INF = 1e9+7;
const double mpi=3.1415926535;
inline int read() {
    int f=1,x=0;char ch;
    do {ch=getchar(); if(ch=='-') f=-1;} while (ch<'0'||ch>'9');
    do {x=x*10+ch-'0'; ch=getchar(); } while (ch>='0'&&ch<='9');
    return x*f;
}

void redirect() {
    #ifdef LOCAL
        freopen("in.txt","r",stdin);
        freopen("out.txt","w",stdout);
    #endif
}

int n,f[N],sz[N],dis[N];
char opt;

int find(int x){
    if(x==f[x])return x;
    int u=find(f[x]);
    dis[x]+=dis[f[x]];
    f[x]=u;
    return f[x];
}

int main() {
    redirect();
    int T=1;
    //scanf("%d",&T);
    while(T--){
        scanf("%d",&n);
        for(int i=1;i<=30000;i++)f[i]=i,sz[i]=1;
        for(int i=1;i<=n;i++){
            int x,y;
            cin>>opt>>x>>y;
            if(opt=='M'){
                int fa=find(x),fb=find(y);
                if(fa==fb)continue;
                f[fa]=fb;
                dis[fa]=sz[fb];
                sz[fb]+=sz[fa];
            } else {
                int fa=find(x),fb=find(y);
                if(fa!=fb)puts("-1");
                else printf("%d\n",x==y?0:abs(dis[x]-dis[y])-1);
            }
        }
    }
    return 0;
}
```

## 树与线段树

1给出一棵树 n个节点 每个节点有一个权值x 查询(A,B)上链的最大子段和 将(A,B)链上的所有点权变为c

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define lson rt<<1
#define rson rt<<1|1

const int N=1e5+5,M=2e5+5;
int n,q,tot,x[N],lnk[N],ter[M],nxt[M];
int idx,dfn[N],seq[N],sz[N],dep[N],hvy[N],top[N],fa[N];
struct Node {
    int sum,lmx,rmx,ret,tag;
    bool cov;
    Node() {sum=lmx=rmx=ret=0;}
}seg[N<<2];

void add(int u,int v) {
    ter[++tot]=v,nxt[tot]=lnk[u],lnk[u]=tot;
}
void dfs1(int u,int f) {
    dep[u]=dep[f]+1,fa[u]=f,sz[u]=1;
    for(int i=lnk[u];i;i=nxt[i]) {
        int v=ter[i];
        if(v==f) continue;
        dfs1(v,u);
        sz[u]+=sz[v];
        if(sz[v]>sz[hvy[u]]) hvy[u]=v;
    }
}
void dfs2(int u,int tp) {
    dfn[u]=++idx,seq[idx]=u,top[u]=tp;
    if(!hvy[u]) return;
    dfs2(hvy[u],tp);
    for(int i=lnk[u];i;i=nxt[i]) {
        int v=ter[i];
        if(v==fa[u]||v==hvy[u]) continue;
        dfs2(v,v);
    }
}
Node merge(Node x,Node y) {
    Node ans;
    ans.sum=x.sum+y.sum;
    ans.lmx=std::max(x.lmx,x.sum+y.lmx);
    ans.rmx=std::max(y.rmx,y.sum+x.rmx);
    ans.ret=std::max(std::max(x.ret,y.ret),x.rmx+y.lmx);
    ans.tag=ans.cov=0;
    return ans;
}
void build(int rt,int l,int r) {
    if(l==r) {
        seg[rt].sum=x[seq[l]];
        seg[rt].lmx=seg[rt].rmx=seg[rt].ret=std::max(seg[rt].sum,0);
        seg[rt].cov=0;
        return;
    }
    int mid=(l+r)>>1;
    build(lson,l,mid);
    build(rson,mid+1,r);
    seg[rt]=merge(seg[lson],seg[rson]);
}
void update(int rt,int l,int r,int k) {
    seg[rt].sum=(r-l+1)*k;
    seg[rt].lmx=seg[rt].rmx=seg[rt].ret=std::max(seg[rt].sum,0);
    seg[rt].cov=1,seg[rt].tag=k;
}
void pushdown(int rt,int l,int r) {
    if(!seg[rt].cov) return;
    int mid=(l+r)>>1;
    update(lson,l,mid,seg[rt].tag);
    update(rson,mid+1,r,seg[rt].tag);
    seg[rt].tag=seg[rt].cov=0;
}
void modify(int x,int y,int rt,int l,int r,int k) {
    if(x<=l&&r<=y) {
        update(rt,l,r,k);
        return;
    }
    pushdown(rt,l,r);
    int mid=(l+r)>>1;
    if(x<=mid) modify(x,y,lson,l,mid,k);
    if(mid<y) modify(x,y,rson,mid+1,r,k);
    seg[rt]=merge(seg[lson],seg[rson]);
}
Node query(int x,int y,int rt,int l,int r) {
    if(x<=l&&r<=y) return seg[rt];
    pushdown(rt,l,r);
    int mid=(l+r)>>1;
    Node L,R;
    if(x<=mid) L=query(x,y,lson,l,mid);
    if(mid<y) R=query(x,y,rson,mid+1,r);
    return merge(L,R);
}
void chainModify(int u,int v,int k) {
    for(int fu=top[u],fv=top[v];fu^fv;u=fa[fu],fu=top[u]) {
        if(dep[fu]<dep[fv]) std::swap(u,v),std::swap(fu,fv);
        modify(dfn[fu],dfn[u],1,1,n,k);
    }
    if(dep[u]>dep[v]) std::swap(u,v);
    modify(dfn[u],dfn[v],1,1,n,k);
}
Node chainQuery(int u,int v) {
    Node L,R;
    for(int fu=top[u],fv=top[v];fu^fv;) {
        if(dep[fu]<dep[fv]) {
            R=merge(query(dfn[fv],dfn[v],1,1,n),R);
            v=fa[fv],fv=top[v];
        } else {
            L=merge(query(dfn[fu],dfn[u],1,1,n),L);
            u=fa[fu],fu=top[u];
        }
    }
    if(dep[u]>dep[v]) {
        L=merge(query(dfn[v],dfn[u],1,1,n),L);
    } else {
        R=merge(query(dfn[u],dfn[v],1,1,n),R);
    }
    std::swap(L.lmx,L.rmx);
    return merge(L,R);
}
int main() {
    scanf("%d",&n);
    for(int i=1;i<=n;++i) scanf("%d",&x[i]);
    for(int i=1;i<n;++i) {
        int u,v;
        scanf("%d%d",&u,&v);
        add(u,v),add(v,u);
    }
    dfs1(1,0),dfs2(1,1),build(1,1,n);
    scanf("%d",&q);
    while(q--) {
        int opt;
        scanf("%d",&opt);
        if(opt==1) {
            int l,r;
            scanf("%d%d",&l,&r);
            printf("%d\n",chainQuery(l,r).ret);
        } else {
            int l,r,k;
            scanf("%d%d%d",&l,&r,&k);
            chainModify(l,r,k);
        }
    }
    return 0;
}
```

2以1为根的有根树 满足(x,y)的点对数量 保证一个点不为另一个点的祖先 且Vx+Vy=2*Vlca(x,y) 两者之间距离小于等于k

```c++
#include<bits/stdc++.h>
#define ll long long
#define mid ((l+r)>>1)
using namespace std;
const int maxn = 1e5 + 50;
int n, k;
vector<int> g[maxn];
int val[maxn], son[maxn], dep[maxn], sz[maxn];
int T[maxn], lc[maxn*200], rc[maxn*200], tot = 0, sum[maxn*200];
void update(int &rt, int l, int r, int pos, int x){
    if(!rt) rt = ++tot;
    sum[rt] += x;
    if(l == r) return;
    if(pos <= mid) update(lc[rt], l, mid, pos, x);
    else update(rc[rt], mid+1, r, pos, x);
}
int qry(int rt, int l, int r, int L, int R){
    if(!rt) return 0;
    if(L <= l && r <= R) return sum[rt];
    int res = 0;
    if(L <= mid) res += qry(lc[rt], l, mid, L, R);
    if(R > mid) res += qry(rc[rt], mid+1, r, L, R);
    return res;
}
ll ans = 0;
void init(){
    scanf("%d%d", &n, &k);
    for(int i = 1; i <= n; ++i) scanf("%d", &val[i]);
    for(int i = 2; i <= n; ++i){int u; scanf("%d", &u); g[u].push_back(i);}
}
void dfs1(int u){
    sz[u] = 1;
    for(int i = 0; i < g[u].size(); ++i){
        int v = g[u][i];
        dep[v] = dep[u]+1;
        dfs1(v);  sz[u] += sz[v];
        if(sz[v] > sz[son[u]]) son[u] = v;
    }return;
}
void del(int u){
    update(T[val[u]], 1, n, dep[u], -1);
    for(int i = 0; i < g[u].size(); ++i) del(g[u][i]);
}
void qry(int u, int td, int tv){
    int d = k+2*td-dep[u];
    d = min(d, n);//Attention!!
    int t = 2*tv-val[u];
    if(d >= 1 && t >= 0 && t <= n)  ans = ans + 2LL*qry(T[t], 1, n, 1, d);
    for(int i = 0; i < g[u].size(); ++i) qry(g[u][i], td, tv);
}
void add(int u){
    update(T[val[u]], 1, n, dep[u], 1);
    for(int i = 0; i < g[u].size(); ++i) add(g[u][i]);
}
void dfs2(int u){

    for(int i = 0; i < g[u].size(); ++i){
        int v = g[u][i];
        if(v == son[u]) continue;
        dfs2(v);del(v);
    }
    if(son[u]) dfs2(son[u]);
    for(int i = 0; i < g[u].size(); ++i){
        int v = g[u][i];  if(v == son[u]) continue;
        qry(v, dep[u], val[u]);  add(v);
    }
    update(T[val[u]], 1, n, dep[u], 1);
}
int main()
{
    init();
    dep[1] = 1;
    dfs1(1);dfs2(1);
    cout<<ans<<endl;
}
```

## 分块

区间[L,R]内等于x的数量

```c++
int query(int l,int r,int x){
    int cl=li(l),cr=li(r);
    int res=0;
    if(cl==cr){
        for(int i=l;i<=r;i++)
            if(a[i]%x==0)res++;
        return res;
    }
    for(int i=l;i<=cl*k;i++)
        if(a[i]%x==0)res++;
    for(int i=cl+1;i<cr;i++){
        int le=(i-1)*k+1;
        int ri=i*k;
        int now=b[le]/x*x;//改这边
        for(int j=now;j<=b[ri];j+=x){
            if(j>b[ri])break;
            res+=upper_bound(b+le,b+ri+1,j)-lower_bound(b+le,b+ri+1,j);
        }
    }
    for(int i=(cr-1)*k+1;i<=r;i++)
        if(a[i]%x==0)res++;
    return res;
}
/*等于x倍数的数量
#include <bits/stdc++.h>

using namespace std;

int n, m;
int ar[100050];
int sum[320][100050];
int l, r, x, d;

void fenkuai()
{
    d = sqrt(n);
    for(int i = 0; i < n; ++i)
    {
        for(int j = 1; j * j <= ar[i]; ++j)
        {
            if(ar[i] % j == 0)
            {
                sum[i / d][j]++;
                if(ar[i] / j != j)  sum[i / d][ar[i] / j]++;
            }
        }
    }
}

int solve(int l, int r, int x)
{
    //cout << d << endl;
    int ans = 0;
    for(int i = l; i <= r && i / d == l / d; ++i) if(ar[i] % x == 0)    ans++;
    if(l / d == r / d)  return ans;
    for(int i = r / d * d; i <= r ; ++i)   if(ar[i] % x == 0)  ans++;
    for(int i = l / d + 1; i <= r / d - 1; ++i) ans += sum[i][x];
    return ans;
}

int main()
{
    scanf("%d%d", &n, &m);
    for(int i = 0; i < n; ++i) scanf("%d", &ar[i]);
    fenkuai();
    for(int i = 1; i <= m; ++i)
    {
        scanf("%d%d%d", &l, &r, &x);
        --l, --r;
        int ans = solve(l, r, x);
        printf("%d\n", ans);
    }
    return 0;
}
*/
```

## 在p处插入x 删除p处的元素 修改p处的元素x 查询[l,r]的最大子段和

```c++
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <algorithm>
#include <queue>
#include <map>
#include <vector>
#include <ctime>
using namespace std;
#define go(i, j, n, k) for(int i = j; i <= n; i += k)
#define fo(i, j, n, k) for(int i = j; i >= n; i -= k)
#define mn 400010
#define inf 1 << 30
#define ll long long
inline int read() {
    int x = 0, f = 1; char ch = getchar();
    while(ch > '9' || ch < '0') { if(ch == '-') f = -f; ch = getchar(); }
    while(ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
}
struct tree{
    int pri, ch[2], sze;
    ll x, sum, lsum, rsum, msum;
} z[mn];
inline void update(int rt)
{
    z[rt].sum = z[rt].x, z[rt].sze = 1;
    if (z[rt].ch[0])
        z[rt].sum += z[z[rt].ch[0]].sum, z[rt].sze += z[z[rt].ch[0]].sze;
    if (z[rt].ch[1])
        z[rt].sum += z[z[rt].ch[1]].sum, z[rt].sze += z[z[rt].ch[1]].sze;
    if (z[rt].ch[0] && z[rt].ch[1]) {
        z[rt].lsum = max(z[z[rt].ch[0]].lsum, z[z[rt].ch[0]].sum + z[rt].x + z[z[rt].ch[1]].lsum);
        z[rt].rsum = max(z[z[rt].ch[1]].rsum, z[z[rt].ch[1]].sum + z[rt].x + z[z[rt].ch[0]].rsum);
        z[rt].msum = max(max(z[z[rt].ch[0]].msum, z[z[rt].ch[1]].msum), z[z[rt].ch[0]].rsum + z[z[rt].ch[1]].lsum + z[rt].x);
    } else if (z[rt].ch[0]) {
        z[rt].lsum = max(max(z[z[rt].ch[0]].lsum, z[z[rt].ch[0]].sum + z[rt].x), 0ll);
        z[rt].rsum = max(z[z[rt].ch[0]].rsum + z[rt].x, 0ll);
        z[rt].msum = max(z[z[rt].ch[0]].msum, z[z[rt].ch[0]].rsum + z[rt].x);
    } else if (z[rt].ch[1]) {
        z[rt].lsum = max(z[z[rt].ch[1]].lsum + z[rt].x, 0ll);
        z[rt].rsum = max(max(z[z[rt].ch[1]].rsum, z[z[rt].ch[1]].sum + z[rt].x), 0ll);
        z[rt].msum = max(z[z[rt].ch[1]].msum, z[z[rt].ch[1]].lsum + z[rt].x);
    } else {
        z[rt].lsum = z[rt].rsum = max(z[rt].x, 0ll);
        z[rt].msum = z[rt].x;
    }
}
int cnt;
inline int newnode(int v = 0) {
    z[++cnt].x = z[cnt].msum = z[cnt].sum = v;
    z[cnt].lsum = z[cnt].rsum = max(v, 0);
    z[cnt].sze = 1;
    z[cnt].pri = rand();
    return cnt;
}
inline int merge(int x, int y) {
    if(!x || !y) return x + y;
    if(z[x].pri < z[y].pri) {
        z[x].ch[1] = merge(z[x].ch[1], y);
        update(x);
        return x;
    } else {
        z[y].ch[0] = merge(x, z[y].ch[0]);
        update(y);
        return y;
    }
}
inline void split(int rt, int k, int &x, int &y) {
    if(!rt) x = y = 0;
    else {
        if(k <= z[z[rt].ch[0]].sze) {
            y = rt, split(z[rt].ch[0], k, x, z[rt].ch[0]);
        } else {
            x = rt, split(z[rt].ch[1], k - z[z[rt].ch[0]].sze - 1, z[rt].ch[1], y);
        }
        update(rt);
    }
}
int n, m, xx, yy, zz, rot;
inline void debug() {
    go(rt, 1, cnt, 1) {
        printf("%d: pri:%d, sze:%d, ch[0]:%d, ch[1]:%d, x:%d\n", rt, z[rt].pri, z[rt].sze, z[rt].ch[0], z[rt].ch[1], z[rt].x);
    }
    printf("\n");
}
int main() {
    srand((unsigned)time(NULL));
    n = read();
    go(i, 1, n, 1) {
        int x = read();
        split(rot, i, xx, yy);
        rot = merge(merge(xx, newnode(x)), yy);
    } 
    m = read();
    go(i, 1, m, 1) {
        char s;
        cin >> s;
        int x = read(), v;
        if(s == 'I') {
            v = read();
            split(rot, x - 1, xx, yy);	
            rot = merge(merge(xx, newnode(v)), yy);
            
        } else if(s == 'D') {
            split(rot, x, xx, zz);
            split(xx, x - 1, xx, yy);
            yy = merge(z[yy].ch[0], z[yy].ch[1]);
            rot = merge(merge(xx, yy), zz);
        } else if(s == 'R') {
            v = read();
            split(rot, x, xx, zz);
            split(xx, x - 1, xx, yy);
            z[yy].x = v;
            z[yy].sum = z[yy].msum = v;
            z[yy].lsum = z[yy].rsum = max(v, 0);
            rot = merge(merge(xx, yy), zz);
        } else if(s == 'Q') {
            v = read();
            split(rot, v, xx, zz);
            split(xx, x - 1, xx, yy);
            printf("%lld\n", z[yy].msum);
            rot = merge(merge(xx, yy), zz);
        }
    }
    return 0;
}
```

## 待修改求区间Mex

![image-20210414085422239](C:\Users\11323\AppData\Roaming\Typora\typora-user-images\image-20210414085422239.png)

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2e5 + 5;
int n, m;
long long a[maxn];
struct ex {
    vector <pair <long long ,long long> > vec;
    
    int init(long long x){
        vec.clear();
        vec.push_back(make_pair(x, x));
        return 0;
    }
};
ex merge(ex x, ex y){
    ex ret;
    ex tmp;
    tmp.vec.resize(x.vec.size() + y.vec.size());
    
    merge(x.vec.begin(), x.vec.end(), y.vec.begin(), y.vec.end(), tmp.vec.begin());
    
    ret.vec.push_back(tmp.vec[0]);
    
    for(int i=1;i<tmp.vec.size();i++){
        pair <long long, long long> p = tmp.vec[i];
        if(ret.vec.back().second + ret.vec.back().first >= p.first){
            ret.vec.back().second += p.second;
        }else{
            ret.vec.push_back(p);
        }
    }
    
    return ret;
}
struct stnode {
    int l, r;
    int lc, rc;
    ex inf;
};
struct st {
    stnode tree[maxn * 4];
    int tc;
    int root;
    
    int init_tree(int l, int r){
        int mid = (l + r) / 2;
        int pos = ++tc;
        
        tree[pos].l = l;
        tree[pos].r = r;
        
        if(l == r){
            tree[pos].inf.init(a[l]);
            return pos;
        }
        
        tree[pos].lc = init_tree(l, mid);
        tree[pos].rc = init_tree(mid + 1, r);
        
        tree[pos].inf = merge(tree[tree[pos].lc].inf, tree[tree[pos].rc].inf);
        
        return pos;
    }
    
    ex query_tree(int pos, int l, int r){
        int mid = (tree[pos].l + tree[pos].r) / 2;
        
        if(tree[pos].l == l and r == tree[pos].r){
            return tree[pos].inf;
        }else{
            if(r <= mid){
                return query_tree(tree[pos].lc, l, r);
            }else if(l <= mid){
                return merge(query_tree(tree[pos].lc, l, mid), query_tree(tree[pos].rc, mid + 1, r));
            }else{
                return query_tree(tree[pos].rc, l, r);
            }
        }
    }
    
    int update_tree(int pos, int p, long long x){
        int mid = (tree[pos].l + tree[pos].r) / 2;
        
        if(tree[pos].l == tree[pos].r){
            tree[pos].inf.init(x);
        }else{
            if(p <= mid){
                update_tree(tree[pos].lc, p, x);
            }else{
                update_tree(tree[pos].rc, p, x);
            }
            tree[pos].inf = merge(tree[tree[pos].lc].inf, tree[tree[pos].rc].inf);
        }
        return 0;
    }
    
    long long query(int l, int r){
        ex ret = query_tree(root, l, r);
        if(ret.vec[0].first != 1)return 1; 
        return ret.vec[0].second + 1;
    }
    
    int update(int p, long long x){
        update_tree(root, p, x);
        return 0;
    }
    
    int init(int x){
        int i, j;
        tc = 0;
        
        root = init_tree(1, x);
        
        return 0;
    }
} tree;
int read(){
    int x;
    scanf("%d", &x);
    return x;
}
int main(){
    int i, j;
    int x, y;
    int opt;
    
    n = read();
    m = read();
    
    for(i=1;i<=n;i++){
        a[i] = read();
    }
    
    tree.init(n);
    
    while(m--){
        opt = read();
        x = read();
        y = read();
        
        if(opt == 1){
            tree.update(x, y);
        }else{
            printf("%lld\n", tree.query(x, y));
        }
    }
    
    return 0;
}
/*
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 2e5+10;
int n, m, len;
ll a[maxn];
inline int lowbit(int x){
    return x&(-x);
}
ll sum[maxn*80];
int ls[maxn*80];
int rs[maxn*80];
int rt[maxn*80];
int tot;
void update_SgT(int &rt, int l, int r, int x, int val)
{
    if(!rt) rt = ++tot;
    if(l == r)
    {
        sum[rt] += val;
        return;
    }
    int mid = (l+r)>>1;
    if(x <= mid) update_SgT(ls[rt], l, mid, x, val);
    else update_SgT(rs[rt], mid+1, r, x, val);
    sum[rt] = sum[ls[rt]] + sum[rs[rt]];
}
void update_BIT(int pos, int x, int val)
{
    for(int i = pos; i <= n; i += lowbit(i))
        update_SgT(rt[i], 1, len, x, val);
}
int rt1[maxn], rt2[maxn], cnt1, cnt2;
void locate(int l, int r)
{
    cnt1 = cnt2 = 0;
    for(int i = l-1; i; i -= lowbit(i))
        rt1[++cnt1] = rt[i];
    for(int i = r; i; i -= lowbit(i))
        rt2[++cnt2] = rt[i];
}
ll ask(int l, int r, int k)
{
    ll ans = 0;
    if(r == k)
    {
        for(int i = 1; i <= cnt1; i++)
            ans -= sum[rt1[i]];
        for(int i = 1; i<= cnt2; i++)
            ans += sum[rt2[i]];
        return ans;
    }
    int mid = (l+r)>>1;
    if(k <= mid)
    {
        for(int i = 1; i <= cnt1; i++)
            rt1[i] = ls[rt1[i]];
        for(int i = 1; i <= cnt2; i++)
            rt2[i] = ls[rt2[i]];
        return ask(l, mid, k);
    }
    else
    {
        for(int i = 1; i <= cnt1; i++)
            ans -= sum[ls[rt1[i]]];
        for(int i = 1; i <= cnt2; i++)
            ans += sum[ls[rt2[i]]];
        for(int i = 1; i <= cnt1; i++)
            rt1[i] = rs[rt1[i]];
        for(int i = 1; i <= cnt2; i++)
            rt2[i] = rs[rt2[i]];
        return ans + ask(mid+1, r, k);
    }
}
int main()
{
    scanf("%d%d", &n, &m);
    len = maxn-10;
    for(int i = 1; i <= n; i++)
        scanf("%lld", &a[i]);
    for(int i = 1; i <= n; i++)
        update_BIT(i, a[i], a[i]);
    for(int i = 1, op, x, y; i <= m; i++)
    {
        scanf("%d%d%d", &op, &x, &y);
        if(op == 1) //修改操作
        {
            update_BIT(x, a[x], -a[x]);
            a[x] = y;
            update_BIT(x, y, y);
        }
        else
        {
            ll now = 1;
            ll s = 0;
            while(true)
            {
                locate(x, y);
                int t = min(now, 200000ll);
                ll tmp = ask(1, len, t);
                if(tmp == s)
                {
                    printf("%lld\n", now);
                    break;
                }
                s = tmp, now = s+1;
            }
        }
    }
    return 0;
}
*/
```

